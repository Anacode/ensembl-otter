#!/nfs/humace2/hum/bin/perl -w

### ana_notes

use strict;
use GenomeCanvas;
use Hum::Submission 'prepare_statement';
use Hum::AnaStatus::Sequence;
use Hum::AnaStatus::SequenceSet;
use Hum::Conf qw{ HUMACESERVER_HOST HUMGIFACESERVER_PORT };
use GenomeCanvas::Band::SeqChooser;
use Carp;
use Getopt::Long 'GetOptions';

{
    my( $annotator );
    GetOptions(
        'help!'     => \&useage,
        'user=s'    => \$annotator,
        ) or useage();
    my $set_name = shift(@ARGV) || useage();
    die "Unknown elements on command line: '@ARGV'\n" if @ARGV;
    
    if ($annotator) {
        die "Invalid annotator '$annotator'" unless is_valid_annotator($annotator);
    }
    
    my $set_id = set_name_to_set_id($set_name);
    
    my $mw = CanvasWindow::MainWindow->new;
    $mw->title($set_name);
    my $gc = GenomeCanvas->new($mw);
    my $chooser = GenomeCanvas::Band::SeqChooser->new;
    $gc->add_Band($chooser);
    $chooser->chooser_map(make_chooser_map($set_id));
    $gc->render;
    $gc->fix_window_min_max_sizes;
    
    my $canvas = $gc->canvas;
    $canvas->CanvasBind('<Button-1>', sub {
        deselect_all_selected_not_current($gc);
        toggle_current($gc);
        });
    $canvas->CanvasBind('<Shift-Button-1>', sub {
        toggle_current($gc);
        });
    
    {
        my( $comment );
        if ($annotator) {
            my $button_frame = $mw->Frame;
            $button_frame->pack(
                -side => 'top',
                );

            my $comment_label = $button_frame->Label(
                -text => 'Comment:',
                );
            $comment_label->pack(
                -side => 'left',
                );

            $comment = $button_frame->Entry(
                -width => 55,
                );
            $comment->pack(
                -side => 'left',
                );
        }
        
        
        my $button_frame2 = $mw->Frame;
        $button_frame2->pack(
            -side => 'top',
            );
        
        if ($annotator) {
            my $set_reviewed = sub{
                my $c = $comment->get;
                my @ana_seq_id_list = list_selected_ana_seq_ids($canvas);
                return unless @ana_seq_id_list;
                set_reviewed($annotator, $c, @ana_seq_id_list);
                $chooser->chooser_map(make_chooser_map($set_id));
                $gc->set_window_size(1);
                $gc->render;
                $gc->fix_window_min_max_sizes
                };
            make_button($button_frame2, 'Set reviewed', $set_reviewed, 0);
            $mw->bind('<Control-s>', $set_reviewed);
            $mw->bind('<Control-S>', $set_reviewed);
        }
        
        my $hunter = sub{
            watch_cursor($mw);
            hunt_for_selection($gc);
            default_cursor($mw);
            };
        
        # First call to this returns empty list!
        my @all_text_obj = $canvas->find('withtag', 'contig_text');
        
        make_button($button_frame2, 'Hunt selection', $hunter, 0);
        $mw->bind('<Control-h>', $hunter);
        $mw->bind('<Control-H>', $hunter);
        
        my $refesher = sub{
            watch_cursor($mw);
            $chooser->chooser_map(make_chooser_map($set_id));
            $gc->set_window_size(1);
            $gc->render;
            $gc->fix_window_min_max_sizes;
            default_cursor($mw);
            };
        make_button($button_frame2, 'Refresh', $refesher, 0);
        $mw->bind('<Control-r>', $refesher);
        $mw->bind('<Control-R>', $refesher);
        $mw->bind('<F5>', $refesher);

        if ($annotator) {
            my $run_lace = sub{
                watch_cursor($mw);
                my @sequence_name_list = list_selected_sequence_names($canvas);
                return unless @sequence_name_list;
                fork_lace_process(@sequence_name_list);
                default_cursor($mw);
                };
            make_button($button_frame2, 'Run lace', $run_lace, 4);
            $mw->bind('<Control-l>', $run_lace);
            $mw->bind('<Control-L>', $run_lace);
            
            my $do_embl_dump = sub{
                watch_cursor($mw);
                my @sequence_name_list = list_selected_sequence_names($canvas);
                foreach my $seq (@sequence_name_list) {
                    do_embl_dump($seq);
                }
                default_cursor($mw);
                };
            make_button($button_frame2, 'EMBL dump', $do_embl_dump, 0);
            $mw->bind('<Control-e>', $do_embl_dump);
            $mw->bind('<Control-E>', $do_embl_dump);
        }
        
        make_button($button_frame2, 'Quit', sub{ Tk::exit() }, 0);
    }
    
    ###############
    Tk::MainLoop();
    ###############
}

sub set_name_to_set_id {
    my( $set_name ) = @_;
    
    my $sth = prepare_statement(q{
        SELECT set_id
        FROM ana_set
        WHERE set_name = ?
        });
    $sth->execute($set_name);
    my ($set_id) = $sth->fetchrow;
    
    if ($set_id) {
        return $set_id;
    } else {
        die "No such set '$set_name'\n";
    }
}

sub watch_cursor {
    my( $w ) = @_;
    
    $w->configure( -cursor => 'watch' );
    $w->update;
}

sub default_cursor {
    my( $w ) = @_;
    
    $w->configure( -cursor => undef );
    $w->update;
}

{
    my( %lace_dir );

    sub fork_lace_process {
        my( @seq_name_list ) = @_;

        # Record the lace db directory of each
        # of the sequences.
        my $lace_dir = (getpwuid($<))[7] . '/.lace';
        my $lace_dir_suffix = "_${HUMACESERVER_HOST}_$HUMGIFACESERVER_PORT";
        my $lace_seq_home = "$lace_dir/$seq_name_list[0]$lace_dir_suffix";
        foreach my $seq (@seq_name_list) {
            $lace_dir{$seq} = $lace_seq_home;
        }

        if (my $pid = fork) {
            $SIG{'CHLD'} = 'IGNORE';
            sleep 15;   # Prevent multiple button presses
            return 1;
        }
        elsif (defined $pid) {
            exec('lace', '-noacetmp', @seq_name_list);
        }
        else {
            die "Error: Can't fork : $!";
        }
    }
    
    sub do_embl_dump {
        my( $sequence_name ) = @_;
        
        my $ana_seq = Hum::AnaStatus::Sequence->new_from_sequence_name($sequence_name);
        my $ana_dir = $ana_seq->analysis_directory;
        my @embl_dump_command = ('emblDump', '-dump', $ana_dir, $sequence_name);
        if (my $lace_dir = $lace_dir{$sequence_name}) {
            push(@embl_dump_command, '-path', $lace_dir);
        }
        warn "Running '@embl_dump_command'\n";
        system(@embl_dump_command) == 0
            or die "Error running : '@embl_dump_command'";
    }
}

sub hunt_for_selection {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    
    my( $query_str );
    eval {
        $query_str = $canvas->SelectionGet;
    };
    return if $@;
    #warn "Looking for '$query_str'";
    my $matcher = make_matcher($query_str);
    
    my $current_obj;
    foreach my $obj ($canvas->find('withtag', 'selected')) {
        $current_obj ||= $obj;
        toggle_selection($gc, $obj);
    }
    
    my $selected_text_obj = $canvas->selectItem;
    my @all_text_obj = $canvas->find('withtag', 'contig_text');
    if ($selected_text_obj) {
        if ($selected_text_obj == $all_text_obj[$#all_text_obj]) {
            # selected obj is last on list, so is to leave at end
        } else {
            for (my $i = 0; $i < @all_text_obj; $i++) {
                if ($all_text_obj[$i] == $selected_text_obj) {
                    my @tail = @all_text_obj[$i + 1 .. $#all_text_obj];
                    my @head = @all_text_obj[0 .. $i];
                    @all_text_obj = (@tail, @head);
                    last;
                }
            }
        }
    }

    my $found = 0;
    foreach my $obj (@all_text_obj) {
        my $text = $canvas->itemcget($obj, 'text');
        my $hit = &$matcher($text);
        if ($hit) {
            $canvas->selectClear;
            my $start = index($text, $hit);
            die "Can't find '$hit' in '$text'" if $start == -1;
            $canvas->selectFrom($obj, $start);
            $canvas->selectTo  ($obj, $start + length($hit) - 1);
            $found = $obj;
            last;
        }
    }
    
    unless ($found) {
        warn "Can't find '$query_str'\n";
        return;
    }
    
    $gc->scroll_to_obj($found);
    
    my @overlapping = $canvas->find('overlapping', $canvas->bbox($found));
    foreach my $obj (@overlapping) {
        my @tags = $canvas->gettags($obj);
        if (grep $_ eq 'contig_seq_rectangle', @tags) {
            unless (grep $_ eq 'selected', @tags) {
                toggle_selection($gc, $obj);
            }
        }
    }
}

sub make_matcher {
    my( $pattern ) = @_;
    
    # Escape non word characters
    $pattern =~ s{(\W)}{\\$1}g;
    
    my $matcher = eval "sub {
        my( \$text ) = \@_;
        
        \$text =~ /($pattern)/i;
        return \$1;
        }";
    if ($@) {
        die "Error in pattern '$pattern' \n$@";
    } else {
        return $matcher;
    }
}

sub list_selected_ana_seq_ids {
    my( $canvas ) = @_;
    
    my @selected_objects = $canvas->find('withtag', 'selected');
    my( @ana_seq_id_list );
    foreach my $obj (@selected_objects) {
        my ($ana_seq_id) = map /ana_seq_id=(\d+)/, $canvas->gettags($obj); 
        die "Found selected object without ana_seq_id" unless $ana_seq_id;
        push(@ana_seq_id_list, $ana_seq_id);
    }
    return @ana_seq_id_list;
}

sub list_selected_sequence_names {
    my( $canvas ) = @_;
    
    my @selected_objects = $canvas->find('withtag', 'selected');
    my( @sequence_name_list );
    foreach my $obj (@selected_objects) {
        my ($sequence_name) = map /sequence_name=(.+)/, $canvas->gettags($obj); 
        die "Found selected object without sequence_name" unless $sequence_name;
        push(@sequence_name_list, $sequence_name);
    }
    return @sequence_name_list;
}

sub set_reviewed {
    my( $user, $comment, @ana_seq_id ) = @_;

    foreach my $id (@ana_seq_id) {
        add_new_entry($id, $user, $comment);
    }
}

{
    my( $sth );
    
    sub add_new_entry {
        my( $id, $user, $comment ) = @_;
        
        $sth ||= prepare_statement(q{
            INSERT ana_sequence_review( ana_seq_id
                  , annotator_uname
                  , review_time
                  , review_comment)
            VALUES(?,?,NOW(),?)
            });
        $sth->execute($id, $user, $comment);
        $sth->rows or confess "Error inserting [$id, $user, $comment]";
    }
}


sub make_button {
    my( $parent, $label, $command, $underline_index ) = @_;
    
    my @args = (
        -text => $label,
        -command => $command,
        );
    push(@args, -underline => $underline_index)
        if defined $underline_index;
    my $button = $parent->Button(@args);
    $button->pack(
        -side => 'left',
        );
    return $button;
}

sub is_valid_annotator {
    my( $annotator ) = @_;

    my $sth = prepare_statement(q{
        SELECT annotator_uname
        FROM ana_person
        });
    $sth->execute;

    while (my( $db_ann ) = $sth->fetchrow) {
        return 1 if $db_ann eq $annotator;
    }
    return 0;
}


sub toggle_current {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    
    my ($ana_seq) = grep /^ana_seq_id=/, $canvas->gettags('current');
    return unless $ana_seq;

    my ($rec) = $canvas->find('withtag', "$ana_seq&&contig_seq_rectangle");        
    toggle_selection($gc, $rec);
}

sub deselect_all_selected_not_current {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    foreach my $obj ($canvas->find('withtag', 'selected&&!current')) {
        toggle_selection($gc, $obj);
    }
}

sub toggle_selection {
    my( $gc, $obj ) = @_;
    
    my $canvas = $gc->canvas;
    my $is_selected = grep $_ eq 'selected', $canvas->gettags($obj);
    my( $new_colour ); 
    if ($is_selected) {
        $new_colour = '#aaaaff';
        $canvas->dtag($obj, 'selected');
    } else {
        $new_colour = '#ffcccc';
        $canvas->addtag('selected', 'withtag', $obj);
    }
    $canvas->itemconfigure($obj,
        -fill => $new_colour,
        );
}

sub useage {
    exec('perldoc', $0);
}

sub make_chooser_map {
    my( $set_id ) = @_;
    
    confess "No set_id given" unless $set_id;
    
    print STDERR "Getting set notes...";
    
    my $sql = qq{
        SELECT s.sequence_name
          , a.ana_seq_id
          , st.status_id
          , r.annotator_uname
          , r.review_time
          , r.review_comment
        FROM sequence s
          , ana_sequence a
          , ana_status st
          , species_chromosome c
          , ana_sequence_set ss
        LEFT JOIN ana_sequence_review r
          ON a.ana_seq_id = r.ana_seq_id
        WHERE s.seq_id = a.seq_id
          AND a.ana_seq_id = st.ana_seq_id
          AND s.chromosome_id = c.chromosome_id
          AND a.ana_seq_id = ss.ana_seq_id
          AND a.is_current = 'Y'
          AND st.is_current = 'Y'
          AND ss.set_id = $set_id
        ORDER BY ss.rank ASC
          , r.review_time DESC
        };
    my $sth = prepare_statement($sql);
    $sth->execute;

    my( $seq_name, $ana_seq_id, $status, $uname, $date, $comment );
    $sth->bind_columns(
        \$seq_name, \$ana_seq_id, \$status, \$uname, \$date, \$comment,
        );
    
    my( @map );
    while ($sth->fetch) {
        ($date) = $date =~ /(\d{4}-\d\d-\d\d)/ if $date;
        $status = status_name($status);
        push(@map,
            [ $ana_seq_id, $seq_name, $status, $uname, $date, $comment ]
            );
    }
    
    print STDERR " got them.\n";
    
    return @map;
}

sub get_unplaced_clones {
    my( @map ) = @_;
    
    my %is_placed = map {$_->[1], 1} grep $_->[1], @map;
    my( @unplaced );
    foreach my $seq_name (list_all_seq_names())  {
        push(@unplaced, $seq_name) unless $is_placed{$seq_name};
    }
    return @unplaced;
}

{
    my( %id_status );
    
    sub status_name {
        my( $id ) = @_;
        
        unless (%id_status) {
            my $sth = prepare_statement(q{
                SELECT status_id
                  , status_name
                FROM ana_status_dict
                });
            $sth->execute;
            while (my( $id, $name ) = $sth->fetchrow) {
                $id_status{$id} = $name;
            }
        }
        return $id_status{$id};
    }
}



__END__

=head1 NAME - ana_notes

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

