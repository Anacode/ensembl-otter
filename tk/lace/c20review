#!/usr/local/bin/perl -w

### chr_20_ana_review

use strict;
use GenomeCanvas;
use Hum::Submission 'prepare_statement';
use GenomeCanvas::Band::SeqChooser;
use Bio::EnsEMBL::DBSQL::Obj;
use Carp;
use Getopt::Long 'GetOptions';

{
    my $host = 'ensrv3';
    my $db   = 'chr20';
    my $user = 'ensro';
    my $fpc  = 'chr20';
    my $help = 0;
    my($annotator);
    GetOptions(
        'help!'     => \$help,
        'user=s'    => \$annotator,
        ) or useage();
    useage() if $help;
    useage() unless $annotator;
    die "Invalid annotator '$annotator'" unless is_valid_annotator($annotator);
    
    my $ensdb = Bio::EnsEMBL::DBSQL::Obj->new(
        -DBNAME => $db,
        -USER   => $user,
        -HOST   => $host,
        );
    
    my $mw = GenomeCanvas::MainWindow->new;
    $mw->title($fpc);
    my $gc = GenomeCanvas->new($mw);
    my $chooser = GenomeCanvas::Band::SeqChooser->new;
    $gc->add_Band($chooser);
    $chooser->chooser_map(make_chooser_map($ensdb, $fpc));
    $gc->render;
    $gc->fix_window_min_max_sizes;
    
    my $canvas = $gc->canvas;
    $canvas->CanvasBind('<1>', sub { selection_manager($gc) });
    
    {
        my $button_frame = $mw->Frame;
        $button_frame->pack(
            -side => 'top',
            );
        
        my $comment_label = $button_frame->Label(
            -text => 'Comment:',
            );
        $comment_label->pack(
            -side => 'left',
            );
        
        my $comment = $button_frame->Entry(
            -width => 50,
            );
        $comment->pack(
            -side => 'left',
            );
        
        my $button_frame2 = $mw->Frame;
        $button_frame2->pack(
            -side => 'top',
            );
        
        make_button($button_frame2, 'Set reviewed', sub{
            my $c = $comment->get;
            my @ana_seq_id_list = list_selected_ana_seq_ids($canvas);
            return unless @ana_seq_id_list;
            set_reviewed($annotator, $c, @ana_seq_id_list);
            $chooser->chooser_map(make_chooser_map());
            $gc->render;
            $gc->fix_window_min_max_sizes;
        });

        make_button($button_frame2, 'Run lace', sub{
            my @ana_seq_id_list = list_selected_ana_seq_ids($canvas);
            return unless @ana_seq_id_list;
            fork_lace_process(@ana_seq_id_list);
        });
        
        make_button($button_frame2, 'Exit', sub{ exit } );
    }
    
    ###############
    Tk::MainLoop();
    ###############
}

sub fork_lace_process {
    my( @ana_seq_ids ) = @_;
    
    my $ana_seq_in_clause = join(',', map "'$_'", @ana_seq_ids);
    my $sql = qq{
        SELECT a.ana_seq_id
          , s.sequence_name
        FROM sequence s
          , ana_sequence a
        WHERE s.seq_id = a.seq_id
          AND a.ana_seq_id IN ($ana_seq_in_clause)
        };
    my $sth = prepare_statement($sql);
    $sth->execute;
    my( %seq_name );
    while (my($as_id, $seq_name) = $sth->fetchrow) {
        $seq_name{$as_id} = $seq_name;
    }
    my( @seq_name_list );
    foreach my $as_id (@ana_seq_ids) {
        my $seq_name = $seq_name{$as_id}
            or die "Didn't find sequence name for ana_seq_id '$as_id'";
        push(@seq_name_list, $seq_name);
    }
    
    if (my $pid = fork) {
        $SIG{'CHLD'} = 'IGNORE';
        sleep 15;
        return 1;
    }
    elsif (defined $pid) {
        exec('lace', @seq_name_list);
    }
    else {
        die "Error: Can't fork : $!";
    }
}

sub list_selected_ana_seq_ids {
    my( $canvas ) = @_;
    
    my @selected_objects = $canvas->find('withtag', 'selected');
    my( @ana_seq_id_list );
    foreach my $obj (@selected_objects) {
        my ($ana_seq_id) = map /ana_seq_id=(\d+)/, $canvas->gettags($obj); 
        die "Found selected object without ana_seq_id" unless $ana_seq_id;
        push(@ana_seq_id_list, $ana_seq_id);
    }
    return @ana_seq_id_list;
}

sub set_reviewed {
    my( $user, $comment, @ana_seq_id ) = @_;

    foreach my $id (@ana_seq_id) {
        add_new_entry($id, $user, $comment);
    }
}

{
    my( $sth );
    
    sub add_new_entry {
        my( $id, $user, $comment ) = @_;
        
        $sth ||= prepare_statement(q{
            INSERT ana_sequence_review( ana_seq_id
                  , annotator_uname
                  , review_time
                  , review_comment)
            VALUES(?,?,NOW(),?)
            });
        $sth->execute($id, $user, $comment);
        $sth->rows or confess "Error inserting [$id, $user, $comment]";
    }
}


sub make_button {
    my( $parent, $label, $command ) = @_;
    
    my $button = $parent->Button(
        -text => $label,
        -command => $command,
        );
    $button->pack(
        -side => 'left',
        );
    return $button;
}

sub is_valid_annotator {
    my( $annotator ) = @_;

    my $sth = prepare_statement(q{
        SELECT annotator_uname
        FROM ana_person
        });
    $sth->execute;

    while (my( $db_ann ) = $sth->fetchrow) {
        return 1 if $db_ann eq $annotator;
    }
    return 0;
}


sub selection_manager {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    
    my ($ana_seq) = grep /^ana_seq_id=/, $canvas->gettags('current');
    return unless $ana_seq;

    my ($rec) = $canvas->find('withtag', "$ana_seq&&contig_seq_rectangle");        
    toggle_selection($gc, $rec);
}

sub toggle_selection {
    my( $gc, $tag ) = @_;
    
    my $canvas = $gc->canvas;
    my $colour = $canvas->itemcget($tag, '-fill');
    my( $new_colour ); 
    if ($colour eq '#ccccff') {
        $new_colour = '#ffcccc';
        $canvas->addtag('selected', 'withtag', $tag);
    } else {
        $new_colour = '#ccccff';
        $canvas->dtag($tag, 'selected');
    }
    $canvas->itemconfigure($tag,
        -fill => $new_colour,
        );
}

sub useage {
    exec('perldoc', $0);
}

sub make_chooser_map {
    my( $ensdb, $ctg_name ) = @_;
    
    reset_review_details_cache();
    my @map = get_fpc_contig_map($ensdb, $ctg_name);
    for (my $i = 0; $i < @map; $i++) {
        my $acc = $map[$i][0];
        if ($acc eq '__GAP__') {
            my $gap_size = $map[$i][1];
            $map[$i] = [ "GAP of ${gap_size}bp" ];
        } else {
            my $seq_name = seq_name_from_acc($acc) || $acc;
            $map[$i] = [review_details($seq_name)];
        }
    }
    
    if (my @unplaced = get_unplaced_clones(@map)) {
        push(@map, ['Unplaced clones']);
        foreach my $un (@unplaced) {
            push(@map, [review_details($un)]);
        }
    }
    
    return @map;
}

sub get_unplaced_clones {
    my( @map ) = @_;
    
    
    my %is_placed = map {$_->[1], 1} grep $_->[1], @map;
    my( @unplaced );
    foreach my $seq_name (list_all_seq_names())  {
        push(@unplaced, $seq_name) unless $is_placed{$seq_name};
    }
    return @unplaced;
}

{
    my( %seq_review_details );

    sub reset_review_details_cache {
        %seq_review_details = ();
    }

    sub list_all_seq_names {
        return sort keys %seq_review_details;
    }
    
    sub review_details {
        my( $seq_name ) = @_;

        unless (%seq_review_details) {
            print STDERR "Getting review details...";
            my $sql = qq{
                SELECT s.sequence_name
                  , a.ana_seq_id
                  , r.annotator_uname
                  , r.review_time
                  , r.review_comment
                FROM sequence s
                  , ana_sequence a
                  , species_chromosome c
                LEFT JOIN ana_sequence_review r
                  ON a.ana_seq_id = r.ana_seq_id
                WHERE s.seq_id = a.seq_id
                  AND s.chromosome_id = c.chromosome_id
                  AND a.is_current = 'Y'
                  AND c.chromosome_id = 20
                };
            my $sth = prepare_statement($sql);
            $sth->execute;
            while (my ($seq_name, @details) = $sth->fetchrow) {
                $seq_review_details{$seq_name} ||= [];
                push( @{$seq_review_details{$seq_name}}, [@details] );
            }
            print STDERR " got them\n";
        }
        my ($most_recent) = sort {$b->[2] cmp $a->[2]} @{$seq_review_details{$seq_name}};
        confess "No review data for '$seq_name'" unless $most_recent;
        my( $ana_seq_id, $uname, $date, $comment ) = @$most_recent;
        ($date) = $date =~ /(\d{4}-\d\d-\d\d)/ if $date;
        return( $ana_seq_id, $seq_name, $uname, $date, $comment );
    }
}

{
    my( %acc_seq );
    
    sub seq_name_from_acc {
        my( $acc ) = @_;
        
        unless (%acc_seq) {
            my $sth = prepare_statement(q{
                SELECT acc.accession
                  , s.sequence_name
                FROM project_acc acc
                  , project_dump d
                  , sequence s
                WHERE acc.sanger_id = d.sanger_id
                  AND d.seq_id = s.seq_id
                  AND d.is_current = 'Y'
                });
            $sth->execute();
            while (my($acc, $seq_name) = $sth->fetchrow) {
                $acc_seq{$acc} = $seq_name;
            }
        }
        return $acc_seq{$acc};
    }
}

{
    my( @map );
    
    sub get_fpc_contig_map {
        my( $ensdb, $ctg_name ) = @_;

        unless (@map) {
            print STDERR "Getting ftp contig map...";
            my $sth = $ensdb->prepare(qq{
                SELECT c.id
                  , sgp.chr_start
                  , sgp.chr_end
                FROM static_golden_path sgp
                  , contig raw
                  , clone c
                WHERE sgp.raw_id = raw.internal_id
                  AND raw.clone = c.internal_id
                  AND sgp.fpcctg_name = '$ctg_name'
                ORDER BY sgp.chr_start ASC
                  , sgp.chr_end ASC
                });
            $sth->execute;
            my $prev_end = 0;
            while (my($acc, $start, $end) = $sth->fetchrow) {
                #printf("%12s  %5d  %5d\n", $acc, $start, $end);
                if (my $gap = $start - ($prev_end + 1)) {
                    #print "GAP  $gap\n";
                    push(@map, ['__GAP__', $gap]);
                }
                push(@map, [$acc, $start, $end]);
                $prev_end = $end;
            }
            $ensdb = undef; # Disconnect from the ensembl db
            print STDERR " done\n";
        }
        return @map;
    }
}

__END__

=head1 NAME - chr_20_ana_review

=head1 SYNOPISS

    chr_20_ana_review -user <username>

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

