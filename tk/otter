#!/usr/local/bin/perl5.6.1 -w


### otter

use strict;
use Carp;
use Hum::AnaStatus::Sequence;
use Hum::AnaStatus::EnsAnalysis;
use Bio::Otter::Lace::AceDatabase;
use Bio::Otter::Lace::Client;
use Getopt::Long 'GetOptions';
use Symbol 'gensym';

{
    my $usage = sub{ exec('perldoc', $0) };
    my $host = 'ecs1d';
    my $port = 39312;
    my $ace_tar = '/nfs/team71/analysis/jgrg/work/ace_skeleton/lace_acedb.tar';
    my $recover = '';
    my $write_flag  = 0;
    my $unlock_flag = 0;

    GetOptions(
        'view'      => sub{ $write_flag = 0 },
        'host=s'    => \$host,
        'port=i'    => \$port,
        'tar=s'     => \$ace_tar,
        'h|help'    => $usage,
        'write!'    => \$write_flag,
        'recover=s' => \$recover,
        'unlock!'   => \$unlock_flag,
        ) or $usage->();
    die "Can't specify both write and unlock\n"
        if $unlock_flag and $write_flag;

    my $cl = Bio::Otter::Lace::Client->new;
    $cl->host('ecs1d');
    $cl->port(39312);
    $cl->write_access($write_flag);
    
    my $db = $cl->new_AceDatabase;
    $db->title('lace test');
    $db->error_flag(1);
    $db->tar_file($ace_tar);

    if ($recover) {
        $db->home($recover);
        $db->recover_slice_dataset_hash;
    } else {
        ### Need a Dataset chooser
        my $ds = $cl->get_DataSet_by_name('otter_chr9p12');
        
        ### Need a CloneSequence chooser
        my $cs_list = $ds->get_all_CloneSequences;
        $ds->selected_CloneSequences([@$cs_list[2..7]]);


        $db->make_database_directory;
        $db->write_otter_acefile;

        ### Fetch data for CloneSequences
        fetch_sanger_data($ds, $db);
        #debug_print_sequence($ds, $db);

        unless ($db->initialize_database) {
            die "Error initialzing database";
        }
    }
    
    warn "Database is in '", $db->home, "'\n";
    
    if ($unlock_flag) {
        $db->unlock_all_slices;
    } else {
        system('xace', $db->home);
    }

    if ($write_flag) {
        $db->save_all_slices;
    }

    #my $mw = CanvasWindow::MainWindow->new('Otter: datasets');
    #my $cw = CanvasWindow->new($mw, 400, 300);
    #
    #my $datasets = get_dataset_details($host, $port);
    #set_details($datasets);
    #show_dataset_list($cw, $datasets);
    #$cw->canvas->toplevel->bind( '<Return>', sub{ do_fetch($cw) } );
    #
    #$cw->fix_window_min_max_sizes;
    #Tk::MainLoop();
    
    $db->error_flag(0);     # OK to cleanup now
}

sub fetch_sanger_data {
    my( $dataset, $acedb ) = @_;

    my $ace_file = $acedb->home . "/rawdata/sanger.ace";
    my $fh = gensym();
    open $fh, "> $ace_file" or confess "Can't write to '$ace_file' : $!";
    $acedb->add_acefile($ace_file);
    
    my $sel = $dataset->selected_CloneSequences;
    foreach my $cs (@$sel) {
        my $ana = Hum::AnaStatus::Sequence->new_from_accession($cs->accession);
        my ($acc, $sv) = $ana->get_accession_and_sv;
        unless ($cs->accession eq $acc and $cs->sv == $sv) {
            confess sprintf("Ana sequence '%s.%d' doesn't match otter '%s.%d'",
                $acc, $sv, $cs->accession, $cs->sv);
        }
        
        ### Could add in clone end info here - but does not have the
        ### correct name
        #my $ana_dir  = $ana->analysis_directory;
        #my $seq_name = $ana->sequence_name;
        #foreach my $humace (map "$ana_dir/rawdata/$seq_name.humace.$_", qw{ ace ace.gz }) {
        #    if (-e $humace) {
        #        $acedb->add_acefile($humace);
        #        last;
        #    }
        #}
        
        my $seq = $ana->hum_Sequence;
        my $full = $seq->name;
        my $ctg_name = $cs->contig_name;
        $seq->name($ctg_name);
        print $fh
            $seq->ace_string,
            qq{\nSequence "$ctg_name"\nClone "$full"\n};
    }
    
    close $fh;
}

sub debug_print_sequence {
    my( $dataset, $acedb ) = @_;
    
    my $sa = $dataset->get_cached_DBAdaptor->get_SliceAdaptor;
    foreach my $ctg (@{$dataset->selected_CloneSequences_as_contig_list}) {
        my $chr_name  = $ctg->[0]->chromosome->name;
        my $start     = $ctg->[0]->chr_start;
        my $end       = $ctg->[$#$ctg]->chr_end;
        
        my $slice = $sa->fetch_by_chr_start_end($chr_name, $start, $end);
        my $file = $acedb->home . "/" . $slice->display_id . ".ace";
        my $seqfh = gensym();
        open $seqfh, "> $file" or die;
        my $humseq = Hum::Sequence->new;
        $humseq->sequence_string($slice->seq);
        $humseq->name($slice->display_id);
        print $seqfh $humseq->ace_string;
        close $seqfh;
    }
}

sub do_fetch {
    my( $cw ) = @_;
    
    my $state = get_state();
    if ($state eq 'sequences') {
        run_lace($cw);
    }
    elsif ($state eq 'datasets') {
        my ($obj) = $cw->list_selected;
        warn "No obj" and return unless $obj;
        my $prop = get_canvas_object_properties($cw, $obj);
        if (my $name = $prop->{'name'}) {
            my $details = get_details($name)
                or confess "No details for '$name'";
            draw_sequence_list($cw, $name, $details);
        } else {
            warn "No name property";
        }
    }
    else {
        confess "Unknown state '$state'";
    }
}

{
    my( @cleanup );
    
    END {
        foreach my $thing (@cleanup) {
            if ( -d $thing ) {
                rmtree( $thing, 0 );
            } else {
                unlink($thing);
            }
        }
    }

    sub run_lace {
        my( $cw ) = @_;

        my @sel = $cw->list_selected
            or return;
        my $canvas = $cw->canvas;
        my( @prop );
        foreach my $obj (@sel) {
            push(@prop, get_canvas_object_properties($cw, $obj));
        }

        ### stick this in a subroutine
        my $ctg = [];
        my @contig_list = ($ctg);
        foreach my $this (sort {$a->{'chr_start'} <=> $b->{'chr_start'}} @prop) {
            my $last = $ctg->[$#$ctg];
            if ($last) {
                if ($last->{'chr_end'} + 1 == $this->{'chr_start'}) {
                    push(@$ctg, $this);
                } else {
                    $ctg = [$this];
                    push(@contig_list, $ctg);
                }
            } else {
                push(@$ctg, $this);
            }
        }

        my $home = "/var/tmp/lace.$$";
        warn "Making lace database in '$home'\n";
        mkdir( $home, 0777 ) or die "Can't mkdir('$home') : $!\n";
        chdir($home) or die "Can't chdir ('$home') : $!";

        # List of ace files
        my $lace_files = [];
       
        # Make an empty acedb database
        make_acedb_dir_structure($home, $lace_files, 'otter');
       
        # Get annotatons and dna from otter database.
        my $name_ctg = write_otter_data($cw, $lace_files, @contig_list);
        
        # Make AnaStatus::Sequence objects
        my $acc_anaseq = get_anastatus_sequences(@prop);
        fetch_pipeline_data($lace_files, values %$acc_anaseq);
        
        write_sMap_assembly_info($name_ctg, $lace_files, $acc_anaseq);
        
        # Parse all the acefiles into the database
        my $errors = initializeDatabase( 'tace', $home, $lace_files );
        if ($errors) {
            die "Error detected parsing ace files\n";
        }
        unless ( -e 'database/ACEDB.wrm' ) {
            die "Error: Local database creation failed\n";
        }

        ### launch XaceSeqChooser here ###
        launch_XaceSeqChooser($cw, $home);
        
        ### ace to otter:
        
        ## via acedb:
        # find GenomeSequence
        # show -a
        # follow SubSequence
        # show -a
        # follow Locus
        # show -a
        
        ## or via spandit:
        # express clone subseq fetch followed by ace_string
        
        ## or to xml from spandit?
        
        ### cf Fox::Session
    }
}


sub launch_XaceSeqChooser {
    my( $cw, $home ) = @_;
    
    my $top = $cw->canvas->toplevel->Toplevel(
        -title  => "lace $home",
        );
    my $xc = MenuCanvasWindow::XaceSeqChooser->new($top);
    my %methods_mutable = (
      # Method name            Mutable?
        supported           => 1,
        supported_CDS       => 1,
        supported_mRNA      => 1,
        GD_supported        => 1,
        GD_supported_mRNA   => 1,
        Pseudogene          => 1,
        fgenesh             => 0,
        FGENES              => 0,
        GENSCAN             => 0,
        HALFWISE            => 0,
        SPAN                => 0,
        EnsEMBL             => 0,
        genomewise          => 0,
        );
    $xc->ace_path($home);
    $xc->draw_clone_list;
    $xc->set_known_GeneMethods(%methods_mutable);
    $xc->save_command(\&otter_save);
    $xc->fix_window_min_max_sizes;
}

sub fetch_pipeline_data {
    my( $lace_files, @ana_seq ) = @_;
    
    my $ens_pipe_ace = 'rawdata/enspipe_data.ace';
    push(@$lace_files, $ens_pipe_ace);

    my( @seq_names );
    foreach my $seq (@ana_seq) {
        push(@seq_names, $seq->full_sequence_name);
    }
    
    # Expect to find fetch_old_pipeline_data
    # in same dir as this script.
    my $pipe_data_fetch = 'fetch_old_pipeline_data';
    my $fetch_cmd = "$pipe_data_fetch @seq_names > $ens_pipe_ace";
    warn $fetch_cmd;
    system($fetch_cmd) == 0
        or warn "Error from '$fetch_cmd' : exit($?)";
}

sub get_anastatus_sequences {
    my( @prop ) = @_;
    
    my $acc_anaseq = {};
    foreach my $pr (@prop) {
        my $acc = $pr->{'accession'};
        my $sv  = $pr->{'sv'};
        my $ana = Hum::AnaStatus::Sequence->new_from_accession($acc);
        ### Should check sv - do so when new ana_status db is implemented
        unless ($ana) {
            warn "No AnaStatus::Sequence for '$acc'\n";
            next;
        }
        $acc_anaseq->{$acc} = $ana;
    }
    return $acc_anaseq
}

sub write_otter_data {
    my( $cw, $lace_files, @contig_list ) = @_;
    
    my $ace_file = "rawdata/otter.ace";
    push(@$lace_files, $ace_file);

    local *OTTER_ACE;
    open OTTER_ACE, "> $ace_file"
        or confess "Can't write to '$ace_file' : $!";
    my $name_ctg = {};
    foreach my $ctg (@contig_list) {
        my $name = get_otter_ctg($cw, $ctg, \*OTTER_ACE);
        $name_ctg->{$name} = $ctg;
    }
    close OTTER_ACE or confess "Error writing to '$ace_file' : $!";
    return $name_ctg;
}

sub get_otter_ctg {
    my( $cw, $ctg, $fh ) = @_;
    
    my $chr_name  = $ctg->[0]{'chr_name'};
    my $start     = $ctg->[0]{'chr_start'};
    my $end       = $ctg->[$#$ctg]{'chr_end'};
    
    my $dba = current_dba();
    my $aa = $dba->get_SliceAdaptor;
    my $vc = $aa->fetch_by_chr_start_end($chr_name, $start, $end);
    my $genes = $vc->get_all_Genes;
    my $oaga = $dba->get_AnnotatedGeneAdaptor;
    foreach my $gene (@$genes) {
        $oaga->annotate_gene($gene);
    }

    my $name = "${chr_name}_$start-$end";
    $vc->display_id($name);
    print $fh Bio::Otter::Converter::otter_to_ace($vc, $genes,
        $vc->get_tiling_path, $vc->seq);
    return $vc->display_id;
}

sub old_get_otter_ctg {
    my( $cw, $ctg, $fh ) = @_;
    
    my $chr_name  = $ctg->[0]{'chr_name'};
    my $start     = $ctg->[0]{'chr_start'};
    my $end       = $ctg->[$#$ctg]{'chr_end'};
    
    my $dba = current_dba();
    my $aa = $dba->get_SliceAdaptor;
    my $vc = $aa->fetch_by_chr_start_end($chr_name, $start, $end);
    my $genes = $vc->get_all_Genes;
    my $oaga = $dba->get_AnnotatedGeneAdaptor;
    foreach my $gene (@$genes) {
        $oaga->annotate_gene($gene);
    }

    my $name = "${chr_name}_$start-$end";
    $vc->display_id($name);
    print $fh Bio::Otter::Converter::otter_to_ace($vc, $genes,
        $vc->get_tiling_path, $vc->seq);
    return $vc->display_id;
}

sub get_canvas_object_properties {
    my( $cw, $obj ) = @_;
    
    my $canvas = $cw->canvas;
    my $prop = {};
    foreach my $tag_val ($canvas->gettags($obj)) {
        my ($tag, $val) = split /=/, $tag_val, 2;
        next unless $tag and defined($val);
        $prop->{$tag} = $val;
    }
    return $prop;
}

sub show_dataset_list {
    my( $cw, $datasets ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');
    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;
    my $incr = $size + int($size / 6);
    my @sorted_name = sort keys %$datasets;
    for (my $i = 0; $i < @sorted_name; $i++) {
        my $name = $sorted_name[$i];
        my $details = $datasets->{$name};
        my $txt = $canvas->createText(
            $x, $i * $incr,
            -text   => $sorted_name[$i],
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => ["name=$name"],
            );
        $canvas->bind($txt, '<Double-Button-1>', sub{ draw_sequence_list($cw, $name, $details) });
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
    }
    set_state('datasets');
}

{
    my( $current );
    
    sub current_dba {
        my( $dba ) = @_;
        
        if ($dba) {
            $current = $dba;
        }
        return $current;
    }
}

sub draw_sequence_list {
    my( $cw, $name, $details ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');    
    $canvas->toplevel->configure(-title => "Otter: $name");
    my $dba = get_DBAdaptor_from_details($details);
    current_dba($dba);
    my $type = $dba->assembly_type;
    my $sth = $dba->prepare(q{
        SELECT c.embl_acc
          , c.embl_version
          , a.chromosome_id
          , a.chr_start
          , a.chr_end
          , a.contig_start
          , a.contig_end
          , a.contig_ori
        FROM assembly a
          , contig g
          , clone c
        WHERE a.contig_id = g.contig_id
          AND g.clone_id = c.clone_id
          AND a.type = ?
        ORDER BY a.chr_start
        });
    $sth->execute($type);
    my( $acc, $sv, $chr_id,
        $chr_start, $chr_end,
        $contig_start, $contig_end, $strand );
    $sth->bind_columns( \$acc, \$sv, \$chr_id,
        \$chr_start, \$chr_end,
        \$contig_start, \$contig_end, \$strand );

    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;

    my $i = 0;
    my $last_end = 0;
    my( $chr_name );
    while ($sth->fetch) {
        unless ($chr_name) {
            $chr_name = get_chr_name($dba, $chr_id);
        }
        if ($last_end + 1 != $chr_start) {
            #warn "$last_end + 1 != $chr_start\n";
            $i++;
        }
        my $contig_line = sprintf("%-10s  %2d", $acc, $sv);
        my $txt = $canvas->createText(
            $x, $i * (1.2 * $size),
            -text   => $contig_line,
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => [
                "chr_start=$chr_start",
                "chr_end=$chr_end",
                "contig_start=$contig_start",
                "contig_end=$contig_end",
                "contig_ori=$strand",
                "accession=$acc",
                "sv=$sv",
                "chr_name=$chr_name",
                ],
            );
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Control-Button-1>', sub{
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Shift-Button-1>', sub{
            extend_highlighted_region($cw, $txt);
            });
        $canvas->bind($txt, '<Double-Button-1>', sub{ do_fetch($cw) });
        
        $last_end = $chr_end;
        $i++;
    }
    
    set_state('sequences');
    
    $cw->fix_window_min_max_sizes;
}

sub extend_highlighted_region {
    my( $cw, $txt ) = @_;
    
    # list_selected returns object indices sorted
    my @obj = $cw->list_selected;
    my %already_selected = map {$_, 1} @obj;
    
    # We assume that the object indices allocated by
    # the canvas get sequential numbers.
    my $closest = get_nearest($txt, @obj);
    
    my @range = $closest < $txt ? ($closest .. $txt) : ($txt .. $closest);
    foreach my $i (@range) {
        $cw->highlight($i) unless $already_selected{$i};
    }
}

sub get_nearest {
    my( $this, @list ) = @_;
    
    return $this unless @list;
    
    my( $closest, $close_distance );
    foreach my $i (@list) {
        my $distance = $i < $this ? $this - $i : $i - $this;
        if ($closest) {
            next unless $distance < $close_distance;
        }
        $closest = $i;
        $close_distance = $distance;
    }
    
    return $closest;
}



__END__

=head1 NAME - otter

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

