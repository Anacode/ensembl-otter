#!/usr/local/bin/perl5.6.1 -w


### otter

use strict;
use Carp;
use CanvasWindow;
use MenuCanvasWindow::XaceSeqChooser;
use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::Converter;
use Hum::AnaStatus::Sequence;
use Hum::AnaStatus::EnsAnalysis;
use LWP::Simple ();
use Getopt::Long 'GetOptions';

{
    my $usage = sub{ exec('perldoc', $0) };
    my $host = 'localhost';
    my $port = 19312;
    my $ace_tar = '/nfs/humace2/hum/data/lace_acedb.tar';

    if($ENV{"LACE_LOCAL"}){
	$ace_tar=$ENV{"LACE_LOCAL"}."/lace_acedb.tar";
    }

    GetOptions(
        'host=s'    => \$host,
        'port=i'    => \$port,
        'tar=s'     => \$ace_tar,
        'h|help'    => $usage,
        ) or $usage->();

    set_ace_tar($ace_tar);

    my $mw = CanvasWindow::MainWindow->new('Otter: datasets');
    my $cw = CanvasWindow->new($mw, 400, 300);
    
    my $datasets = get_dataset_details($host, $port);
    set_details($datasets);
    show_dataset_list($cw, $datasets);
    $cw->canvas->toplevel->bind( '<Return>', sub{ do_fetch($cw) } );
    
    $cw->fix_window_min_max_sizes;
    Tk::MainLoop();
}

{
    my( $ace_tar );

    sub set_ace_tar {
        $ace_tar = shift;
    }
    
    sub get_ace_tar {
        return $ace_tar;
    }
}

{
    my( $details );

    sub set_details {
        $details = shift;
    }
    
    sub get_details {
        my $name = shift || confess "Missing name argument";
        return $details->{$name};
    }
}

{
    my( $state );
    
    sub set_state {
        $state = shift;
    }
    
    sub get_state {
        return $state;
    }
}

sub do_fetch {
    my( $cw ) = @_;
    
    my $state = get_state();
    if ($state eq 'sequences') {
        run_lace($cw);
    }
    elsif ($state eq 'datasets') {
        my ($obj) = $cw->list_selected;
        warn "No obj" and return unless $obj;
        my $prop = get_canvas_object_properties($cw, $obj);
        if (my $name = $prop->{'name'}) {
            my $details = get_details($name)
                or confess "No details for '$name'";
            draw_sequence_list($cw, $name, $details);
        } else {
            warn "No name property";
        }
    }
    else {
        confess "Unknown state '$state'";
    }
}

{
    my( @cleanup );
    
    END {
        foreach my $thing (@cleanup) {
            if ( -d $thing ) {
                rmtree( $thing, 0 );
            } else {
                unlink($thing);
            }
        }
    }

    sub run_lace {
        my( $cw ) = @_;

        my @sel = $cw->list_selected
            or return;
        my $canvas = $cw->canvas;
        my( @prop );
        foreach my $obj (@sel) {
            push(@prop, get_canvas_object_properties($cw, $obj));
        }

        ### stick this in a subroutine
        my $ctg = [];
        my @contig_list = ($ctg);
        foreach my $this (sort {$a->{'chr_start'} <=> $b->{'chr_start'}} @prop) {
            my $last = $ctg->[$#$ctg];
            if ($last) {
                if ($last->{'chr_end'} + 1 == $this->{'chr_start'}) {
                    push(@$ctg, $this);
                } else {
                    $ctg = [$this];
                    push(@contig_list, $ctg);
                }
            } else {
                push(@$ctg, $this);
            }
        }

        my $home = "/var/tmp/lace.$$";
        warn "Making lace database in '$home'\n";
        mkdir( $home, 0777 ) or die "Can't mkdir('$home') : $!\n";
        chdir($home) or die "Can't chdir ('$home') : $!";

        # List of ace files
        my $lace_files = [];
       
        # Make an empty acedb database
        make_acedb_dir_structure($home, $lace_files, 'otter');
       
        # Get annotatons and dna from otter database.
        my $name_ctg = write_otter_data($cw, $lace_files, @contig_list);
        
        # Make AnaStatus::Sequence objects
        my $acc_anaseq = get_anastatus_sequences(@prop);
        fetch_pipeline_data($lace_files, values %$acc_anaseq);
        
        write_sMap_assembly_info($name_ctg, $lace_files, $acc_anaseq);
        
        # Parse all the acefiles into the database
        my $errors = initializeDatabase( 'tace', $home, $lace_files );
        if ($errors) {
            die "Error detected parsing ace files\n";
        }
        unless ( -e 'database/ACEDB.wrm' ) {
            die "Error: Local database creation failed\n";
        }

        ### launch XaceSeqChooser here ###
        launch_XaceSeqChooser($cw, $home);
        
        ### ace to otter:
        
        ## via acedb:
        # find GenomeSequence
        # show -a
        # follow SubSequence
        # show -a
        # follow Locus
        # show -a
        
        ## or via spandit:
        # express clone subseq fetch followed by ace_string
        
        ## or to xml from spandit?
        
        ### cf Fox::Session
    }
}


sub otter_save {
    my( $self, $name ) = @_;
    
    # Disconnect aceperl
    $self->{'_ace_database_handle'} = undef;
    
    # Get new handle
    my $ace = $self->ace_handle;
    
    ### This code should be in a data only module
    $ace->find(Genome_Sequence => $name);
    my $ace_txt = $ace->raw_query('show -a');
    $ace->raw_query('Follow SubSequence');
    $ace_txt .= $ace->raw_query('show -a');
    $ace->raw_query('Follow Locus');
    $ace_txt .= $ace->raw_query('show -a');
    
    # Cleanup text
    $ace_txt =~ s/\0//g;            # Remove nulls
    $ace_txt =~ s{^\s*//.+}{\n}mg;  # Strip comments
    
    ### Should really use IO::Scalar (or IO::String?)
    my $otter_file = 'otter_out.ace';
    local *OTT;
    open OTT, "> $otter_file" or confess "Can't write to '$otter_file' : $!";
    print OTT $ace_txt;
    close OTT;
    open OTT, $otter_file or confess "Can't read '$otter_file' : $!";
    my $xml =  Bio::Otter::Converter::ace_to_XML(\*OTT);
    print $xml;
}

sub launch_XaceSeqChooser {
    my( $cw, $home ) = @_;
    
    my $top = $cw->canvas->toplevel->Toplevel(
        -title  => "lace $home",
        );
    my $xc = MenuCanvasWindow::XaceSeqChooser->new($top);
    my %methods_mutable = (
      # Method name            Mutable?
        supported           => 1,
        supported_CDS       => 1,
        supported_mRNA      => 1,
        GD_supported        => 1,
        GD_supported_mRNA   => 1,
        Pseudogene          => 1,
        fgenesh             => 0,
        FGENES              => 0,
        GENSCAN             => 0,
        HALFWISE            => 0,
        SPAN                => 0,
        EnsEMBL             => 0,
        genomewise          => 0,
        );
    $xc->ace_path($home);
    $xc->draw_clone_list;
    $xc->set_known_GeneMethods(%methods_mutable);
    $xc->save_command(\&otter_save);
    $xc->fix_window_min_max_sizes;
}

sub write_sMap_assembly_info {
    my( $name_ctg, $lace_acefiles, $acc_anaseq ) = @_;
    
    my $ace_file = 'rawdata/otter_sMap.ace';
    push(@$lace_acefiles, $ace_file);
    local *LACE_SMAP;
    open LACE_SMAP, "> $ace_file" or die "Can't write to '$ace_file' : $!";
    
    while (my ($name, $ctg) = each %$name_ctg) {
        print LACE_SMAP qq{\nSequence : "$name"\n};
        my $offset = $ctg->[0]{'chr_start'} - 1;
        foreach my $prop (@$ctg) {
            ### Should make $prop into a proper object
            my $acc             = $prop->{'accession'};
            my $chr_start       = $prop->{'chr_start'}  - $offset;
            my $chr_end         = $prop->{'chr_end'}    - $offset;
            my $contig_start    = $prop->{'contig_start'};
            my $contig_end      = $prop->{'contig_end'};
            my $strand          = $prop->{'contig_ori'};
            
            my $ana = $acc_anaseq->{$acc} or confess "No ana_seq for '$acc'";
            my $name = $ana->full_sequence_name;
            
            # Clone in reverse orientaton in AGP is indicated
            # to acedb by chr_start > chr_end
            if ($strand == 1) {
                print LACE_SMAP qq{AGP_Fragment "$name" $chr_start $chr_end Align $chr_start $contig_start\n};
            }
            elsif ($strand == -1) {
                print LACE_SMAP qq{AGP_Fragment "$name" $chr_end $chr_start Align $chr_start $contig_end\n};
            } else {
                confess "Unrecognized strand '$strand'";
            }
            ## The length of the fragment is needed where the same sequence ($name)
            ## appears twice in the assembly.  If this happens and length is not
            ## filled in, then acedb gets confused!
            #my $len = $contig_end - $contig_start + 1;
        }
        print LACE_SMAP "\n";
    }
    
    close LACE_SMAP or die "Error writing to '$ace_file' : $!";
}

sub fetch_pipeline_data {
    my( $lace_files, @ana_seq ) = @_;
    
    my $ens_pipe_ace = 'rawdata/enspipe_data.ace';
    push(@$lace_files, $ens_pipe_ace);

    my( @seq_names );
    foreach my $seq (@ana_seq) {
        push(@seq_names, $seq->full_sequence_name);
    }
    
    # Expect to find fetch_old_pipeline_data
    # in same dir as this script.
    my $pipe_data_fetch = 'fetch_old_pipeline_data';
    my $fetch_cmd = "$pipe_data_fetch @seq_names > $ens_pipe_ace";
    warn $fetch_cmd;
    system($fetch_cmd) == 0
        or warn "Error from '$fetch_cmd' : exit($?)";
}

sub make_acedb_dir_structure {
    my( $home, $lace_files, $title ) = @_;

    my $ace_tar = get_ace_tar();
    warn "tar = '$ace_tar'";

    # Make acedb directory structure (includes methods.ace in rawdata)
    my $make_ace_tar = "tar xf $ace_tar";
    system($make_ace_tar) == 0
        or die "Error running '$make_ace_tar' : $!";

    push(@$lace_files, 'rawdata/methods.ace');

    # Create password file
    makePasswdWrm($title);

    # Add title to displays.wrm
    editDisplaysWrm( $home, $title );
}

sub get_anastatus_sequences {
    my( @prop ) = @_;
    
    my $acc_anaseq = {};
    foreach my $pr (@prop) {
        my $acc = $pr->{'accession'};
        my $sv  = $pr->{'sv'};
        my $ana = Hum::AnaStatus::Sequence->new_from_accession($acc);
        ### Should check sv - do so when new ana_status db is implemented
        unless ($ana) {
            warn "No AnaStatus::Sequence for '$acc'\n";
            next;
        }
        $acc_anaseq->{$acc} = $ana;
    }
    return $acc_anaseq
}

sub write_otter_data {
    my( $cw, $lace_files, @contig_list ) = @_;
    
    my $ace_file = "rawdata/otter.ace";
    push(@$lace_files, $ace_file);

    local *OTTER_ACE;
    open OTTER_ACE, "> $ace_file"
        or confess "Can't write to '$ace_file' : $!";
    my $name_ctg = {};
    foreach my $ctg (@contig_list) {
        my $name = get_otter_ctg($cw, $ctg, \*OTTER_ACE);
        $name_ctg->{$name} = $ctg;
    }
    close OTTER_ACE or confess "Error writing to '$ace_file' : $!";
    return $name_ctg;
}

sub get_otter_ctg {
    my( $cw, $ctg, $fh ) = @_;
    
    my $chr_name  = $ctg->[0]{'chr_name'};
    my $start     = $ctg->[0]{'chr_start'};
    my $end       = $ctg->[$#$ctg]{'chr_end'};
    
    my $dba = current_dba();
    my $aa = $dba->get_SliceAdaptor;
    my $vc = $aa->fetch_by_chr_start_end($chr_name, $start, $end);
    my $genes = $vc->get_all_Genes;
    my $oaga = $dba->get_AnnotatedGeneAdaptor;
    foreach my $gene (@$genes) {
        $oaga->annotate_gene($gene);
    }

    my $name = "${chr_name}_$start-$end";
    $vc->display_id($name);
    print $fh Bio::Otter::Converter::otter_to_ace($vc, $genes,
        $vc->get_tiling_path, $vc->seq);
    return $vc->display_id;
}

sub get_canvas_object_properties {
    my( $cw, $obj ) = @_;
    
    my $canvas = $cw->canvas;
    my $prop = {};
    foreach my $tag_val ($canvas->gettags($obj)) {
        my ($tag, $val) = split /=/, $tag_val, 2;
        next unless $tag and defined($val);
        $prop->{$tag} = $val;
    }
    return $prop;
}

sub show_dataset_list {
    my( $cw, $datasets ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');
    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;
    my @sorted_name = sort keys %$datasets;
    for (my $i = 0; $i < @sorted_name; $i++) {
        my $name = $sorted_name[$i];
        my $details = $datasets->{$name};
        my $txt = $canvas->createText(
            $x, $i * (1.2 * $size),
            -text   => $sorted_name[$i],
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => ["name=$name"],
            );
        $canvas->bind($txt, '<Double-Button-1>', sub{ draw_sequence_list($cw, $name, $details) });
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
    }
    set_state('datasets');
}

{
    my( $current );
    
    sub current_dba {
        my( $dba ) = @_;
        
        if ($dba) {
            $current = $dba;
        }
        return $current;
    }
}

sub draw_sequence_list {
    my( $cw, $name, $details ) = @_;
    
    my $canvas = $cw->canvas;
    $canvas->delete('all');    
    $canvas->toplevel->configure(-title => "Otter: $name");
    my $dba = get_DBAdaptor_from_details($details);
    current_dba($dba);
    my $type = $dba->assembly_type;
    my $sth = $dba->prepare(q{
        SELECT c.embl_acc
          , c.embl_version
          , a.chromosome_id
          , a.chr_start
          , a.chr_end
          , a.contig_start
          , a.contig_end
          , a.contig_ori
        FROM assembly a
          , contig g
          , clone c
        WHERE a.contig_id = g.contig_id
          AND g.clone_id = c.clone_id
          AND a.type = ?
        ORDER BY a.chr_start
        });
    $sth->execute($type);
    my( $acc, $sv, $chr_id,
        $chr_start, $chr_end,
        $contig_start, $contig_end, $strand );
    $sth->bind_columns( \$acc, \$sv, \$chr_id,
        \$chr_start, \$chr_end,
        \$contig_start, \$contig_end, \$strand );

    my $font = $cw->font;
    my $size = $cw->font_size;
    my $x = $size;

    my $i = 0;
    my $last_end = 0;
    my( $chr_name );
    while ($sth->fetch) {
        unless ($chr_name) {
            $chr_name = get_chr_name($dba, $chr_id);
        }
        if ($last_end + 1 != $chr_start) {
            #warn "$last_end + 1 != $chr_start\n";
            $i++;
        }
        my $contig_line = sprintf("%-10s  %2d", $acc, $sv);
        my $txt = $canvas->createText(
            $x, $i * (1.2 * $size),
            -text   => $contig_line,
            -font   => [$font, $size, 'bold'],
            -anchor => 'nw',
            -tags   => [
                "chr_start=$chr_start",
                "chr_end=$chr_end",
                "contig_start=$contig_start",
                "contig_end=$contig_end",
                "contig_ori=$strand",
                "accession=$acc",
                "sv=$sv",
                "chr_name=$chr_name",
                ],
            );
        $canvas->bind($txt, '<Button-1>', sub{
            $cw->deselect_all;
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Shift-Button-1>', sub{
            $cw->highlight($txt)
            });
        $canvas->bind($txt, '<Double-Button-1>', sub{ do_fetch($cw) });
        
        $last_end = $chr_end;
        $i++;
    }
    
    set_state('sequences');
    
    $cw->fix_window_min_max_sizes;
}

sub get_chr_name {
    my( $dba, $chr_id ) = @_;
    
    my $sth = $dba->prepare(q{
        SELECT name
        FROM chromosome
        WHERE chromosome_id = ?
        });
    $sth->execute($chr_id);
    
    my ($name) = $sth->fetchrow;
    return $name || confess "No name for chromosome_id '$chr_id'";
}

sub get_DBAdaptor_from_details {
    my( $details ) = @_;
    
    my( @args );
    while (my ($key, $val) = each %$details) {
        #warn "  -$key  => $val\n";
        push(@args, "-$key", $val);
    }
    return Bio::Otter::DBSQL::DBAdaptor->new(@args);
}

sub get_dataset_details {
    my( $host, $port ) = @_;

    print STDERR "Fetching dataset list ...";
    my $datasets_url = "http://$host:$port/perl/get_datasets?details=true";
    my $sets = LWP::Simple::get($datasets_url);
    print STDERR " got it\n";
    
    my( $in_details );
    my $datasets = {};
    
    # Split the string into blocks of text which
    # are separated by two or more newlines.
    foreach (split /\n{2,}/, $sets) {
        if (/Details/) {
            $in_details = 1;
            next;
        }
        next unless $in_details;
        my ($name) = /(\S+)/;
        my $opt = $datasets->{$name} = {};
        while (/^\s+(\S+)\s+(\S+)/mg) {
            #warn "$name: $1 => $2\n";
            $opt->{$1} = $2;
        }
    }
    return $datasets;
}


sub makePasswdWrm {
    my( $prog ) = @_;

    my $passWrm       = 'wspec/passwd.wrm';
    my $realNAME      = ( getpwuid($<) )[0];
    my $effectiveNAME = ( getpwuid($>) )[0];

    open PASSWD, ">$passWrm" or die;
    print PASSWD "// passwd.wrm generated by $prog\n",
      "// \"root\" added to cope with weird acedb bug under lstcsh\n\n";

    # acedb looks at the real user ID, but some
    # versions of the code seem to behave differently
    if ( $realNAME ne $effectiveNAME ) {
        print PASSWD "root\n\n$realNAME\n\n$effectiveNAME\n\n";
    }
    else {
        print PASSWD "root\n\n$realNAME\n\n";
    }

    close PASSWD;    # Must close to ensure buffer is flushed into file
    chmod 0644, $passWrm;
}

sub editDisplaysWrm {
    my ( $home, $title ) = @_;
    my $displays = "$home/wspec/displays.wrm";

    open DISP, "< $displays" or die "Can't open '$displays' : $!";
    my @disp = <DISP>;
    close DISP;

    foreach (@disp) {
        next unless /^_DDtMain/;

        # Add our title onto the Main window
        s/\s-t\s*"[^"]+/ -t "$title/i and last;
    }

    open DISPOUT, "> $displays" or die;
    print DISPOUT @disp;
    close DISPOUT;
}

sub initializeDatabase {
    my ( $tace, $dbDir, $acefiles ) = @_;

    my @parse_commands = map "parse $_\n", @$acefiles;

    my $parse_log = 'init_parse.log';
    
    return tace_parse_and_check($tace, $dbDir, $parse_log, "y\n", @parse_commands);
}

sub tace_parse_and_check {
    my( $tace, $dbDir, $parse_log, @parse_commands ) = @_;

    my $pipe = "| $tace $dbDir > $parse_log";
    open TACE, $pipe
        or die "Can't open pipe '$pipe' : $!";
    foreach my $com (@parse_commands) {
        print TACE $com;
    }
    close TACE or die "Error initializing database ($?)\n";

    # This works as well:
    #system("echo 'y\nparse $source' | $tace $dbDir >/dev/null") == 0
    #  or die "Error: Can't initialise database\n";

    local *PARSELOG;
    open PARSELOG, $parse_log or die "Can't open '$parse_log' : $!";
    my $file_log = '';
    my $in_parse = 0;
    my $errors = 0;
    while (<PARSELOG>) {
        if (/parsing/i) {
            $file_log = "  $_";
            $in_parse = 1;
        }
        
        if (/(\d+) (errors|parse failed)/i) {
            if ($1) {
                warn "\nParse error detected:\n$file_log  $_\n";
                $errors++;
            }
        }
        elsif (/Sorry/) {
            warn "Apology detected:\n$file_log  $_\n";
            $errors++;
        }
        elsif ($in_parse) {
            $file_log .= "  $_";
        }
    }
    close PARSELOG;

    return $errors;
}



__END__

=head1 NAME - otter

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

