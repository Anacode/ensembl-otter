#!/usr/local/bin/perl -w

use OtterDefs;
use strict;
use CGI;

use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::AnnotationBroker;
use Bio::Otter::CloneLockBroker;
use Bio::Otter::Converter;
use Bio::Otter::Author;

$| = 1;

print STDERR "\n\n******* Starting to write region *********\n\n";

my $q = new CGI;

if ($ENV{SERVER_SOFTWARE} =~ /libwww-perl-daemon/) {
  print STDERR "NOTE NOTE NOTE Setting nph to 1\n";
  $q->nph(1);
}

my %params = $q->Vars;

my $dataset = $params{dataset} || error_exit($q,"No dataset type entered. Can't write region");
my $data    = $params{data}    || error_exit($q,"No xml data entered. Can't write region");
error_exit($q,"Author must defined to write a region")
       unless $params{author};
my $email   = $params{email}   || error_exit($q,"Email must defined to write a region");

print STDERR "Length of data " . length($data) . "\n";

# Is this just for debugging?
open OTT,">/tmp/apollo.$$.xml";
print OTT $data;
close(OTT);

if (!defined($OTTER_SPECIES->{$params{'dataset'}})) {
  print STDERR "Unknown data set\n";
  error_exit($q, "Unknown data set " . $params{'dataset'} . " in write_region\n");
}

my %dbinfo   = %{$OTTER_SPECIES->{$params{'dataset'}}};
my %defaults = %{$OTTER_SPECIES->{'defaults'}};

my $odb;
my $dnadb;

my $author = Bio::Otter::Author->new(-name  => $params{author},
                                     -email => $params{email});

my $host = $dbinfo{HOST}   || $defaults{HOST},
my $user = $dbinfo{USER}   || $defaults{USER},
my $pass = $dbinfo{PASS}   || $defaults{PASS},
my $port = $dbinfo{PORT}   || $defaults{PORT},
my $dbname = $dbinfo{DBNAME};

#print STDERR "\nDatabase [$dbname][$host][$user][$pass][$port]\n";
#print STDERR "\nAuthor $author email $email dataset $dataset\n";

my $dnahost = $dbinfo{DNA_HOST}    || $defaults{DNA_HOST},
my $dnauser = $dbinfo{DNA_USER}    || $defaults{DNA_USER},
my $dnapass = $dbinfo{DNA_PASS}    || $defaults{DNA_PASS},
my $dnaport = $dbinfo{DNA_PORT}    || $defaults{DNA_PORT},
my $dna_dbname = $dbinfo{DNA_DBNAME};
  
eval {
  $odb = new Bio::Otter::DBSQL::DBAdaptor(-host => $host,
                                          -user => $user,
                                          -pass => $pass,
                                          -port => $port,
                                          -dbname => $dbname);
};
if ($@) {
  error_exit($q, "Failed opening otter database [$@]");
}

print STDERR "Connected to local database\n";

if (defined($dbinfo{DNA_DBNAME})) {
  eval {
    $dnadb = new Bio::EnsEMBL::DBSQL::DBAdaptor(-host   => $dnahost,
                                                -user   => $dnauser,
                                                -pass   => $dnapass,
                                                -port   => $dnaport,
                                                -dbname => $dna_dbname);
  };
  if ($@) {
    error_exit($q, "Failed opening dna database [$@]");
  }
  $odb->dnadb($dnadb);
  
  print STDERR "Connected to dna database\n";
}
my $tmp_xmlfile = get_tmp_file("/tmp","otter","xml");

print STDERR "\nWriting xml to tmp file [" . $tmp_xmlfile . "]\n\n";

open FPOUT,">$tmp_xmlfile" or error_exit($q, "Failed opening temp file for write");

print FPOUT $params{'data'};
close FPOUT;

open(XML,"<$tmp_xmlfile");
my $fh = \*XML;

my $chrname;
my $chrstart;
my $chrend;
my $genes;
my $slice;
my $path;
my $seqstr;
my $sa  = $odb->get_SliceAdaptor;

print STDERR "\nConverting xml to otter...\n";

eval {
    ($genes,$slice,$seqstr,$path) = Bio::Otter::Converter::XML_to_otter($fh,$odb);
    die "no path from XML" unless $path;
    die "empty path from XML" unless @$path;

    $chrname  = $slice->chr_name;
    $chrstart = $slice->chr_start;
    $chrend   = $slice->chr_end;


    print STDERR "Processed incoming xml file :  Chr start end $chrname $chrstart $chrend\n"; 
};
if ($@) {
  print STDERR "Failed converting XML [$genes,$chrname,$chrstart,$chrend][$@]\n";
  error_exit($q, "Failed converting XML to otter [$@]");
}
print STDERR "done\n";

print STDERR "\nFound " . scalar(@$genes) . " genes on region $chrname $chrstart-$chrend\n";


# Get stable IDs for any genes, transcripts, translations and exons that don't have them
my $sida = $odb->get_StableIdAdaptor();
for (my $i = 0; $i < @$genes;) {
    my $gene = $genes->[$i];

    # Can't write incomplete genes
    if ($gene->gene_info->truncated_flag) {
        printf STDERR "Skipping incomplete gene '%s'\n", $gene->gene_info->name->name;
        splice(@$genes, $i, 1);
        next;
    } else {
        $i++;
    }
    
    $gene->stable_id($sida->fetch_new_gene_stable_id)
        unless $gene->stable_id;
    foreach my $trans (@{$gene->get_all_Transcripts}) {
        $trans->stable_id($sida->fetch_new_transcript_stable_id)
            unless $trans->stable_id;
        if (my $translation = $trans->translation) {
            $translation->stable_id($sida->fetch_new_translation_stable_id)
                unless $translation->stable_id;
        }
        foreach my $exon (@{$trans->get_all_Exons}) {
            $exon->stable_id($sida->fetch_new_exon_stable_id)
                unless $exon->stable_id;
        }
    }
}

my $ab = new Bio::Otter::AnnotationBroker($odb);
$ab->current_author($author);
my $oaga = $odb->get_GeneAdaptor();
$odb->assembly_type($slice->assembly_type);

print STDERR "\nFetching slice $chrname $chrstart $chrend...";

print STDERR "done\n";

my $cb   = new Bio::Otter::CloneLockBroker($odb);

print STDERR "Checking region is locked...\n";

eval {
  $cb->check_locks_exist_by_slice($slice, $author);
};
if ($@) {
  error_exit($q, "Failed checking locks [$@]");
}
print STDERR "done\n";

my $anal;

eval {
  $anal = $odb->get_AnalysisAdaptor()->fetch_by_logic_name('otter');
};

if ($@) {
  error_exit($q, "Failed fetching analysis [$@]");
}
if( !defined($anal)) {
  error_exit($q, "No analysis object associated with otter");
}

my $dbgenes;

print STDERR "\nFetching database genes for comparison...";
eval {
  $dbgenes = $oaga->fetch_by_Slice($slice);
};
if ($@) {
  error_exit($q, "Failed fetching genes [$@]");
}

print STDERR "done\n";

foreach my $gene (@$genes) {
  $gene->analysis($anal);
}


# These lines force loads from the database to stop attempted lazy
# loading during the write
eval {
  foreach my $gene (@$dbgenes) {
    my $transcripts = $gene->get_all_Transcripts;
    foreach my $tran (@$transcripts) {
      $tran->translation;
      if ($tran->translation) {
         $tran->translation->stable_id;
      }
      $tran->stable_id;
      my $exons =  $tran->get_all_Exons;
      foreach my $exon (@$exons) {
        $exon->stable_id;
      }
    }
  }
};
if ($@) {
  error_exit($q, "Failed fully loading genes before write [$@]");
}


my( @gene_events, @changed_clones );

print STDERR "New clones\n";
my $new_clones = clones_from_path($path);
print STDERR "Old clones\n";
my $old_clones = clones_from_path($slice->get_tiling_path);


print STDERR "\nComparing annotations " . scalar(@$dbgenes) . " " . scalar(@$genes) . "...\n";

eval {
    print STDERR "trimming old genes to slice:\n";
    my $old_genes = trim_genes_to_slice($dbgenes, $slice);
    print STDERR "trimming new genes to slice:\n";
    my $new_genes = trim_genes_to_slice($genes,  $slice);
    @gene_events = $ab->compare_genes($old_genes, $new_genes);
    @changed_clones = $ab->compare_clones($old_clones, $new_clones);
};
if ($@) {
  error_exit($q, "Failed comparing annotations [$@]");
}
print STDERR "done\n";

# the magic happens!

my $outputstr;
eval {
  $odb->begin_work();

  print STDERR "\nFound " . scalar(@gene_events) . " changed gene annotations\n";
  
  foreach my $event ( @gene_events ) {
    $outputstr .= $event->to_string;
    print STDERR $event->to_string;

    my $gene;

    if ($event->type eq 'deleted') {
      $gene = $event->old_gene;
    } else {
      $gene = $event->new_gene;
    }

    print STDERR "\nAttaching gene to slice " . $gene->stable_id . " " . $gene->version. "\n";
    $oaga->attach_to_Slice($gene,$slice);
    $gene->detach_DBAdaptors;
    print STDERR "Done attaching\n";
    $oaga->store($gene);
    print STDERR "Stored gene\n";
    $outputstr .= " " . $gene->version . " " . $gene->gene_info->name->name . "\n";
  }
  
  my $oaca = $odb->get_AnnotedCloneAdaptor;
  foreach my $clone (@changed_clones) {
    printf STDERR "Storing new version of clone '%s.%s'\n", $clone->embl_id, $clone->embl_version;
    $oaca->store($clone);
  }
  
  $odb->commit();
};

if ($@) {
  error_exit($q, "Failed writing annotations [$@]");
}

#unlink($tmp_xmlfile);

print STDERR "About to write success response\n";
print $q->header();
#print("<otter>\n");
#print("  <response>\n");
if ($outputstr eq "") {
   $outputstr = "No changes to annotations";
}
print($outputstr);
#print("  </response>\n");
#print("</otter>\n");


if ($params{unlock} eq 'true') {
  print STDERR "\nUnlocking clones...";
  $cb->remove_by_slice($slice,$author);
  print STDERR "done\n";
}

#####################################################################################

sub trim_genes_to_slice {
    my( $genes, $slice ) = @_;

    my $start = $slice->chr_start;
    my $end   = $slice->chr_end;

    my $new_genes = [];

    print STDERR "Start end $start $end\n";

    foreach my $g (@$genes) {
        my ($gstart,$gend) = find_gene_ends($g);

        $gstart = $gstart + $start -1;
        $gend   = $gend   + $start -1;

        if ($gstart >= $start and $gend <= $end) {
            print STDERR "Gene inside region " . $gstart . " " . $gend . "\t" . $g->stable_id . "\n";
            push(@$new_genes,$g);
        } else {
            print STDERR "Gene outside region " . $gstart . " " . $gend . "\t" . $g->stable_id . "\n";
        }
    }
    return $new_genes;
}

sub find_gene_ends {
  my ($g) = @_;

  my @exons = @{$g->get_all_Exons}
    or die "No exons in gene '", $g->gene_info->name->name, "'";

  @exons = sort {$a->start <=> $b->start} @exons;

  return ($exons[0]->start,$exons[$#exons]->end);
}
    
sub error_exit {
  my ($q,$reason) = @_;

  print $q->header();

  print "<otter>\n";
  print "  <response>\n";
  print "ERROR:\n$reason\n";
  print "  </response>\n";
  print "</otter>\n";

  print STDERR "ERROR: $reason\n";

  exit(1);
}


sub get_tmp_file {
  my ($dir,$stub,$ext) = @_;


  if ($dir !~ /\/$/) {
    $dir = $dir . "/";
  }

  # This is not good

  my $num = int(rand(10000));
  my $file = $dir . $stub . "." . $num . "." . $ext;

  while (-e $file) {
    $num = int(rand(10000));
    $file = $stub . "." . $num . "." . $ext;
  }

  return $file;
}

sub clones_from_path {
    my( $path ) = @_;

    my $clones = [];
    foreach my $rawcontig (map $_->component_Seq, @$path) {
        my $clone = $rawcontig->clone;
        unless ($clone) {
            printf STDERR "No clone attached to '%s'\n", $rawcontig->id;
            next;
        }
        push(@$clones, $clone);
    }
    return $clones;
}
