#!/usr/local/bin/perl -w

use OtterDefs;
use strict;
use Symbol 'gensym';
use CGI;

use Bio::Otter::DBSQL::DBAdaptor;
use Bio::Otter::AnnotationBroker;
use Bio::Otter::CloneLockBroker;
use Bio::Otter::Converter;
use Bio::Otter::Author;

$| = 1;

print STDERR "\n\n******* Starting to write region *********\n\n";

my $q = new CGI;

if ($ENV{SERVER_SOFTWARE} =~ /libwww-perl-daemon/) {
  print STDERR "NOTE NOTE NOTE Setting nph to 1\n";
  $q->nph(1);
}

my %params = $q->Vars;

my $dataset = $params{'dataset'} || error_exit($q,"No dataset type entered. Can't write region");
error_exit($q,"No xml data entered. Can't write region")
    unless $params{'data'};
error_exit($q,"Author must defined to write a region")
    unless $params{'author'};
my $email = $params{email} || error_exit($q,"Email must defined to write a region");

print STDERR "Length of data " . length($params{'data'}) . "\n";

### Is this just for debugging?
#open OTT,">/tmp/apollo.$$.xml";
#print OTT $params{'data'};
#close(OTT);

unless ($OTTER_SPECIES->{$dataset}) {
  print STDERR "Unknown data set\n";
  error_exit($q, "Unknown data set '$dataset' in write_region\n");
}



my $author = Bio::Otter::Author->new(-name  => $params{author},
                                     -email => $params{email});

my $dbinfo   = $OTTER_SPECIES->{$dataset};
my $defaults = $OTTER_SPECIES->{'defaults'};

my $host   = $dbinfo->{HOST} || $defaults->{HOST};
my $user   = $dbinfo->{USER} || $defaults->{USER};
my $pass   = $dbinfo->{PASS} || $defaults->{PASS};
my $port   = $dbinfo->{PORT} || $defaults->{PORT};
my $dbname = $dbinfo->{DBNAME};

#print STDERR "\nDatabase [$dbname][$host][$user][$pass][$port]\n";
#print STDERR "\nAuthor $author email $email dataset $dataset\n";

my $dnahost    = $dbinfo->{DNA_HOST} || $defaults->{DNA_HOST};
my $dnauser    = $dbinfo->{DNA_USER} || $defaults->{DNA_USER};
my $dnapass    = $dbinfo->{DNA_PASS} || $defaults->{DNA_PASS};
my $dnaport    = $dbinfo->{DNA_PORT} || $defaults->{DNA_PORT};
my $dna_dbname = $dbinfo->{DNA_DBNAME};
  
my( $odb );
eval {
  $odb = new Bio::Otter::DBSQL::DBAdaptor(-host => $host,
                                          -user => $user,
                                          -pass => $pass,
                                          -port => $port,
                                          -dbname => $dbname);
};
if ($@) {
  error_exit($q, "Failed opening otter database [$@]");
}

print STDERR "Connected to local database\n";

my( $dnadb );
if ($dna_dbname) {
  eval {
    $dnadb = new Bio::EnsEMBL::DBSQL::DBAdaptor(-host   => $dnahost,
                                                -user   => $dnauser,
                                                -pass   => $dnapass,
                                                -port   => $dnaport,
                                                -dbname => $dna_dbname);
  };
  if ($@) {
    error_exit($q, "Failed opening dna database [$@]");
  }
  $odb->dnadb($dnadb);
  
  print STDERR "Connected to dna database\n";
}
my $tmp_xmlfile = get_tmp_file("/tmp","otter","xml");

print STDERR "\nWriting xml to tmp file [" . $tmp_xmlfile . "]\n\n";

open FPOUT,">$tmp_xmlfile" or error_exit($q, "Can't write to '$tmp_xmlfile' : $!");
print FPOUT $params{'data'};
close FPOUT;

# Save a bit of memory
$params{'data'} = undef;

my $fh = gensym();
open $fh, $tmp_xmlfile or die "Can't read '$tmp_xmlfile' : $!";

print STDERR "\nConverting xml to otter...\n";

my( $genes, 
    $slice, # The slice is fetched from the database by XML_to_otter
    $path,
    $new_feature_set,   # Arrayref of SimpleFeature objects
    $chrname, $chrstart, $chrend,
    );
eval {
    my( $seqstr );  # Don't need outside block
    ($genes, $slice, $seqstr, $path, $new_feature_set) =
        Bio::Otter::Converter::XML_to_otter($fh, $odb);

    die "no path from XML"    unless  $path;
    die "empty path from XML" unless @$path;

    $chrname  = $slice->chr_name;
    $chrstart = $slice->chr_start;
    $chrend   = $slice->chr_end;

    print STDERR "Processed incoming xml file :  Chr start end $chrname $chrstart $chrend\n"; 
};
if ($@) {
  print STDERR "Failed converting XML [$genes,$chrname,$chrstart,$chrend][$@]\n";
  error_exit($q, "Failed converting XML to otter [$@]");
}
print STDERR "done\n";

print STDERR "\nFound " . scalar(@$genes) . " genes on region $chrname $chrstart-$chrend\n";



print STDERR "Checking region is locked...\n";
my $cb = new Bio::Otter::CloneLockBroker($odb);
eval {
  $cb->check_locks_exist_by_slice($slice, $author);
};
if ($@) {
  error_exit($q, "Failed checking locks [$@]");
}
print STDERR "done\n";

# Get stable IDs for any genes, transcripts, translations and exons that don't have them
my $sida = $odb->get_StableIdAdaptor();
for (my $i = 0; $i < @$genes;) {
    my $gene = $genes->[$i];

    # Can't write incomplete genes
    if ($gene->gene_info->truncated_flag) {
        printf STDERR "Skipping incomplete gene '%s'\n", $gene->gene_info->name->name;
        splice(@$genes, $i, 1);
        next;
    } else {
        $i++;
    }
    
    $gene->stable_id($sida->fetch_new_gene_stable_id)
        unless $gene->stable_id;
    foreach my $trans (@{$gene->get_all_Transcripts}) {
        $trans->stable_id($sida->fetch_new_transcript_stable_id)
            unless $trans->stable_id;
        if (my $translation = $trans->translation) {
            $translation->stable_id($sida->fetch_new_translation_stable_id)
                unless $translation->stable_id;
        }
        foreach my $exon (@{$trans->get_all_Exons}) {
            $exon->stable_id($sida->fetch_new_exon_stable_id)
                unless $exon->stable_id;
        }
    }
}

my $ab = new Bio::Otter::AnnotationBroker($odb);
$ab->current_author($author);
my $oaga = $odb->get_GeneAdaptor();
$odb->assembly_type($slice->assembly_type);


my $anal;

eval {
  $anal = $odb->get_AnalysisAdaptor()->fetch_by_logic_name('otter');
};

if ($@) {
  error_exit($q, "Failed fetching analysis [$@]");
}
if( !defined($anal)) {
  error_exit($q, "No analysis object associated with otter");
}

my $dbgenes;

print STDERR "\nFetching database genes for comparison...";
eval {
  $dbgenes = $oaga->fetch_by_Slice($slice);
};
if ($@) {
  error_exit($q, "Failed fetching genes [$@]");
}

print STDERR "done\n";

foreach my $gene (@$genes) {
  $gene->analysis($anal);
}


# These lines force loads from the database to stop attempted lazy
# loading during the write
eval {
  foreach my $gene (@$dbgenes) {
    my $transcripts = $gene->get_all_Transcripts;
    foreach my $tran (@$transcripts) {
      $tran->translation;
      if ($tran->translation) {
         $tran->translation->stable_id;
      }
      $tran->stable_id;
      my $exons =  $tran->get_all_Exons;
      foreach my $exon (@$exons) {
        $exon->stable_id;
      }
    }
  }
};
if ($@) {
  error_exit($q, "Failed fully loading genes before write [$@]");
}


my( @gene_events, @changed_clones );


print STDERR "\nComparing annotations " . scalar(@$dbgenes) . " " . scalar(@$genes) . "...\n";

my( $del_sf, $save_sf );
eval {
    print STDERR "New clones\n";
    my $new_clones = clones_from_path($path);
    print STDERR "Old clones\n";
    my $old_clones = clones_from_path($slice->get_tiling_path);

    print STDERR "trimming old genes to slice:\n";
    my $old_genes = trim_genes_to_slice($dbgenes, $slice);
    print STDERR "trimming new genes to slice:\n";
    my $new_genes = trim_genes_to_slice($genes,  $slice);
    @gene_events = $ab->compare_genes($old_genes, $new_genes);
    @changed_clones = $ab->compare_clones($old_clones, $new_clones);
    
    # $slice was fetched from the database by XML_to_otter, so we can simply:
    my $old_feature_set = $slice->get_all_SimpleFeatures;
    ($del_sf, $save_sf) = $ab->compare_feature_sets($old_feature_set, $new_feature_set);
};
if ($@) {
  error_exit($q, "Failed comparing annotations [$@]");
}
print STDERR "done\n";

# the magic happens!

my $outputstr;
eval {
  $odb->begin_work();

  print STDERR "\nFound " . scalar(@gene_events) . " changed gene annotations\n";
  
  foreach my $event ( @gene_events ) {
    $outputstr .= $event->to_string;
    print STDERR $event->to_string;

    my $gene;

    if ($event->type eq 'deleted') {
      $gene = $event->old_gene;
    } else {
      $gene = $event->new_gene;
    }

    print STDERR "\nAttaching gene to slice " . $gene->stable_id . " " . $gene->version. "\n";
    $oaga->attach_to_Slice($gene,$slice);
    $gene->detach_DBAdaptors;
    print STDERR "Done attaching\n";
    $oaga->store($gene);
    print STDERR "Stored gene\n";
    $outputstr .= " " . $gene->version . " " . $gene->gene_info->name->name . "\n";
  }
  
  my $oaca = $odb->get_CloneAdaptor;
  foreach my $clone (@changed_clones) {
    my $acc = $clone->embl_id;
    my $sv  = $clone->embl_version;
    printf STDERR "Storing new version of clone '$acc.$sv'\n";
    my $db_clone = $oaca->fetch_by_accession_version($acc, $sv);
    $db_clone->clone_info($clone->clone_info);
    $oaca->store($db_clone);
  }
    
    # Store SimpleFeature changes
    my $sfa = $odb->get_SimpleFeatureAdaptor;
    if (@$del_sf) {
        printf STDERR "Deleting %d SimpleFeatures\n", scalar @$del_sf;
        foreach my $sf (@$del_sf) {
            $sfa->remove($sf);
        }
    }
    if (@$save_sf) {
        attach_analysis_objects_and_transform_to_slice($odb, $slice, $save_sf);
        printf STDERR "Saving %d SimpleFeatures\n", scalar @$save_sf;
        $sfa->store(@$save_sf);
    }
  
  $odb->commit();
};

if ($@) {
  error_exit($q, "Failed writing annotations [$@]");
}

#unlink($tmp_xmlfile);

print STDERR "About to write success response\n";
print $q->header();
#print("<otter>\n");
#print("  <response>\n");
if ($outputstr eq "") {
   $outputstr = "No changes to annotations";
}
print($outputstr);
#print("  </response>\n");
#print("</otter>\n");


if ($params{'unlock'} eq 'true') {
  print STDERR "\nUnlocking clones...";
  $cb->remove_by_slice($slice,$author);
  print STDERR "done\n";
}

#####################################################################################

sub trim_genes_to_slice {
    my( $genes, $slice ) = @_;

    my $start = $slice->chr_start;
    my $end   = $slice->chr_end;

    my $new_genes = [];

    print STDERR "Start end $start $end\n";

    foreach my $g (@$genes) {
        my ($gstart,$gend) = find_gene_ends($g);

        $gstart = $gstart + $start -1;
        $gend   = $gend   + $start -1;

        if ($gstart >= $start and $gend <= $end) {
            print STDERR "Gene inside region " . $gstart . " " . $gend . "\t" . $g->stable_id . "\n";
            push(@$new_genes,$g);
        } else {
            print STDERR "Gene outside region " . $gstart . " " . $gend . "\t" . $g->stable_id . "\n";
        }
    }
    return $new_genes;
}

sub find_gene_ends {
  my ($g) = @_;

  my @exons = @{$g->get_all_Exons}
    or die "No exons in gene '", $g->gene_info->name->name, "'";

  @exons = sort {$a->start <=> $b->start} @exons;

  return ($exons[0]->start,$exons[$#exons]->end);
}
    
sub error_exit {
  my ($q,$reason) = @_;

  print $q->header();

  print "<otter>\n";
  print "  <response>\n";
  print "ERROR:\n$reason\n";
  print "  </response>\n";
  print "</otter>\n";

  print STDERR "ERROR: $reason\n";

  exit(1);
}


sub get_tmp_file {
  my ($dir,$stub,$ext) = @_;


  if ($dir !~ /\/$/) {
    $dir = $dir . "/";
  }

  # This is not good

  my $num = int(rand(10000));
  my $file = $dir . $stub . "." . $num . "." . $ext;

  while (-e $file) {
    $num = int(rand(10000));
    $file = $stub . "." . $num . "." . $ext;
  }

  return $file;
}

sub clones_from_path {
    my( $path ) = @_;

    my $clones = [];
    foreach my $rawcontig (map $_->component_Seq, @$path) {
        my $clone = $rawcontig->clone;
        unless ($clone) {
            printf STDERR "No clone attached to '%s'\n", $rawcontig->id;
            next;
        }
        push(@$clones, $clone);
    }
    return $clones;
}

sub attach_analysis_objects_and_transform_to_slice {
    my( $dba, $slice, $sf_list ) = @_;

    my $analysis_adaptor = $dba->get_AnalysisAdaptor;
    
    my( %logic_ana );
    for (my $i = 0; $i < @$sf_list; $i++) {
        my $sf = $sf_list->[$i];
        my $class = ref($sf);
        my $logic_name = $sf->analysis->logic_name;
        my $ana = $logic_ana{$logic_name}
            ||= $analysis_adaptor->fetch_by_logic_name($logic_name);
        $sf->analysis($ana);
        $sf->contig($slice);
        my @mapped = $sf->transform;
        if (@mapped == 1) {
            unless ($mapped[0]->isa($class)) {
                die "Error, got '$mapped[0]' from transform";
            }
            $sf_list->[$i] = $mapped[0];
        } else {
            die "transform returned ", scalar(@mapped), " features: (@mapped)";
        }
    }
}


