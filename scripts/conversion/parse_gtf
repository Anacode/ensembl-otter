#!/usr/bin/perl

use strict;

$| = 1;

#chr22   Pseudogene      exon    13930399        13931778        .       +       .       Sequence Em:AP000544.C22.1.mRNA
#chr22   Pseudogene      Sequence        13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1 ; Type "pseudogx1ene"; Description "Similar 
#to SW:P11940  Human POLYADENYLATE-BINDING PROTEIN 1 POLY(A) BINDING PROTEIN 1"; Locus "Em:AP000545.C22.1"
#chr22   Pseudogene      exon    13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1
#chr22   GD_mRNA exon    13953869        13954307        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA Sequence        13953869        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA ; Type "coding_gene"; Description "Similar to
# Wp:CE19906  and C2 genomic clone Em:AC002038"; Locus "Em:AP000546.C22.2"
#chr22   GD_CDS  CDS     13954092        13954307        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  Sequence        13954092        13959609        .       -       .       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  CDS     13958471        13958607        .       -       2       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13958471        13958607        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_CDS  CDS     13959501        13959609        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13959501        13959609        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13963439        13963588        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13964426        13964533        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13985077        13985252        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   Pseudogene      Sequence        14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1 ; Type "pseudogene"; Description "Similar 
#to Tr:P32391  ACTIN-LIKE PROTEIN 3"; Locus "Em:AP000546.C22.1"
#chr22   Pseudogene      exon    14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1
#chr22   GD_partial_mRNA exon    14028597        14028683        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA Sequence        14028597        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA ; Type "partial_gene"; Description "S
#imilar to Tr:O96017  Human PROTEIN KINASE."; Locus "Em:AP000547.C22.1"
#chr22   GD_partial_mRNA exon    14033456        14033536        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA exon    14034687        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_mRNA exon    14045473        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA

use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::Transcript;
use Bio::EnsEMBL::DBSQL::DBAdaptor;

my %cds;
my %genes;
my %exons;
my %trans;

my $host = '127.0.0.1';
my $user = 'root';
my $pass = undef;
my $port = 3366;
my $dbname = 'test_gtf';

my $db = new Bio::EnsEMBL::DBSQL::DBAdaptor(-host => $host,
                                            -user => $user,
                                            -pass => $pass,
                                            -port => $port,
                                            -dbname => $dbname);

my $analysis = new Bio::EnsEMBL::Analysis(-logic_name => 'curated');

my $slice = $db->get_SliceAdaptor->fetch_by_chr_name('22');

while (<>) {
  chomp;

  my @arr = split (' ', $_, 9);
  my $start  = $arr[3];
  my $end    = $arr[4];
  my $strand = $arr[6];

  my @arr2 = split (/\;/, $arr[8]);

  my %hashy;
  foreach my $str (@arr2) {
    my ($key, $val) = split (' ', $str, 2);

    # print "Found key $key $val\n";
    $key =~ s/ //g;
    $key =~ s/\"//g;
    $val =~ s/\"//g;
    if ($key ne "Description") {
      $val =~ s/^ +//;
      $val =~ s/ +$//;
      $key =~ s/\t//g;
      $val =~ s/\t//g;
    } else {
      $val =~ s/\t/ /g;
    }

    $hashy{$key} = $val;

    #print "Found key $key $val\n";

  }
  if ($arr[2] eq "Sequence") {
    my $id = $hashy{Sequence};

    $id =~ s/\.mRNA$//;

    $hashy{Sequence} = $id;

    print "Id is now $id\n";
    $genes{$id}{$id}{start}  = $start;
    $genes{$id}{$id}{end}    = $end;
    $genes{$id}{$id}{strand} = $strand;

    if (!defined($genes{$id}{$id}{values}{Type})) {
      $genes{$id}{$id}{values} = \%hashy;
    }
  } elsif ($arr[2] eq "exon") {
    my $id = $hashy{Sequence};

    $id =~ s/\.mRNA$//;

    $hashy{Sequence} = $id;
    if (!defined($exons{$id}{$id}{exons})) {
      $exons{$id}{$id}{exons} = [];
    }
    my %exonhash;
    $exonhash{start}  = $start;
    $exonhash{end}    = $end;
    $exonhash{strand} = $strand;
    $exonhash{values} = \%hashy;
    push (@{ $exons{$id}{$id}{exons} }, \%exonhash);

  } elsif ($arr[2] eq "CDS") {

    if (!defined($cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds})) {
      $cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds} = [];
    }
    my %cdshash;
    $cdshash{start}  = $start;
    $cdshash{end}    = $end;
    $cdshash{strand} = $strand;
    $cdshash{values} = \%hashy;
    push (@{ $cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds} }, \%cdshash);
  }
}

#my $author = new Bio::Otter::Author(
#  -name  => 'Sanger',
#  -email => 'vega@sanger.ac.uk'
#);

foreach my $geneid (keys %genes) {
  print STDERR "Gene id " . $geneid . "\n";

  foreach my $geneid2 (keys %{ $genes{$geneid} }) {
    print STDERR "Gene id 2  $geneid2\n";

    my %values = %{ $genes{$geneid}{$geneid2}{values} };

    foreach my $key (keys %values) {
      print STDERR "Gene Key $key " . $values{$key} . "\n";
    }

    my $gene     = new Bio::EnsEMBL::Gene;
    $gene->analysis($analysis);
    #my $geneinfo = new Bio::Otter::GeneInfo;

    #$gene->gene_info($geneinfo);
    $gene->type($values{'type'});
    #$geneinfo->name(new Bio::Otter::GeneName(-name => $geneid));
    #$geneinfo->author($author);

    #SMJS Added and then removed
    $gene->stable_id($geneid);
    $gene->version(1);
    $gene->created(time);
    $gene->modified(time);


    $values{Description} =~ s/\t/ /g;

    my @evidence;
    if ($values{Description} =~ /^Similar to /) {
      my @descwords = split /\s+/,$values{Description};
      # Remove full stop at end
      $descwords[$#descwords] =~ s/\.$//;
      foreach my $word (@descwords) {
        if ( $word =~ /^..:[A-Z][0-9][0-9][0-9][0-9][0-9]$/ ||
             $word =~ /^..:[A-Z][0-9][A-Z][A-Z][0-9][0-9]$/) {
          print "Evidence: $word looks like an identifier\n";
          #push @evidence,(new Bio::Otter::Evidence(-name => $word, -type => 'Protein'));
          
        } elsif ( $word =~ /^A[A-Z][0-9][0-9][0-9][0-9][0-9][0-9]/ ||
                  $word =~ /^..:[A-Z][0-9][0-9][0-9][0-9][0-9][0-9]$/) {
          print "DNA Evidence: $word looks like an identifier\n";
          #push @evidence,(new Bio::Otter::Evidence(-name => $word, -type => 'cDNA'));
        }
      }
    }

    #my $remark = new Bio::Otter::GeneRemark(-remark => $values{Description});
    #$geneinfo->remark($remark);
    my @tranids = keys(%{ $exons{$geneid} });

    foreach my $tranid (@tranids) {

      my $ecount = 1;
      my $tran     = new Bio::EnsEMBL::Transcript;
      #my $traninfo = new Bio::Otter::TranscriptInfo;
 
      #foreach my $evi (@evidence) {
      #  $traninfo->evidence($evi);
      #}

      $gene->add_Transcript($tran);

      #$tran->transcript_info($traninfo);
      #$traninfo->class(
      #  new Bio::Otter::TranscriptClass(-name => $values{'Type'}));
      #$traninfo->name($tranid);
      #$traninfo->author($author);

      $tran->stable_id($tranid);
      $tran->version(1);
      $tran->created(time);
      $tran->modified(time);

      my %exhash = %{ $exons{$geneid}{$tranid} };
      foreach my $key (keys %exhash) {
        print STDERR "Key $key " . $exhash{$key} . "\n";
      }
      my @exons = @{ $exons{$geneid}{$tranid}{exons} };

      my %evidence;

      foreach my $exon (@exons) {
        my $newexon = new Bio::EnsEMBL::Exon(
          -start  => $exon->{start},
          -end    => $exon->{end},
          -strand => $exon->{strand},
        );

        $tran->add_Exon($newexon);
        $newexon->stable_id($tran->stable_id . ".$ecount");
        $ecount++;
        $newexon->phase(-1);
        $newexon->end_phase(-1);
        $newexon->version(1);
        $newexon->created(time);
        $newexon->modified(time);
        $newexon->contig($slice);
        $newexon->adaptor($db->get_ExonAdaptor);

#Looks like chr 14 to me
#        if (defined($exon->{values}{AC})) {
#          my $acc = $exon->{values}{AC};
#          print STDERR "found evidence $acc\n";
#          $evidence{$acc} = 1;
#        }

        foreach my $key (keys %{ $exon->{values} }) {
          print STDERR "Exon value key $key " . $exon->{values}{$key} . "\n";
        }
      }

#      foreach my $ev (keys %evidence) {
#        my $evidence = new Bio::Otter::Evidence(name => $ev, -type => 'EST');
#        print STDERR "Adding evidence $ev\n";
#        $traninfo->evidence($evidence);
#      }

      # Finally the CDS lines
      # There is only one cds - we have to infer which transcript it belongs to 
      # from the name

      my @tmp = keys(%{ $cds{$geneid} });

      print STDERR "CDS tmp [$tranid] @tmp\n";

      if (scalar(@tmp) == 1) {
        my $tmpid = $tmp[0];

        print STDERR "Ids [$tmpid][$tranid]\n";
        if ($tmpid eq $tranid) {
          my @cdsexons = @{ $cds{$geneid}{$tmpid}{cds} };
          print STDERR "id [$tmpid][$tranid]\n";
          my $mincds = -1;
          my $maxcds = -1;
          foreach my $cdsex (@cdsexons) {
            if ($mincds == -1) {
              $mincds = $cdsex->{start};
            }
            if ($maxcds == -1) {
              $maxcds = $cdsex->{end};
            }
            if ($cdsex->{start} < $mincds) {
              $mincds = $cdsex->{start};
            }
            if ($cdsex->{end} > $maxcds) {
              $maxcds = $cdsex->{end};
            }
            print STDERR "exon "
              . $cdsex->{start} . " "
              . $cdsex->{end} . " "
              . $cdsex->{strand} . "\n";
          }
          print STDERR "Min / max " . $mincds . " " . $maxcds . "\n";

          my $translation = new Bio::EnsEMBL::Translation;
          $translation->stable_id($tran->stable_id);
          $translation->version(1);
          $tran->translation($translation);
          my @exons = @{ $tran->get_all_Exons };
          foreach my $ex (@exons) {

            if ($mincds >= $ex->start && $mincds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->start_Exon($ex);
                $translation->start($mincds - $ex->start + 1);
              } else {
                $translation->end_Exon($ex);
                $translation->end($ex->end - $mincds + 1);
              }
            }
            if ($maxcds >= $ex->start && $maxcds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->end_Exon($ex);
                $translation->end($maxcds - $ex->start + 1);
              } else {
                $translation->start_Exon($ex);
                $translation->start($ex->end - $maxcds + 1);
              }
            }
          }

          # Finally the phase
          if ($exons[0]->strand == 1) {
            @exons = sort { $a->start <=> $b->start } @exons;
          } else {
            @exons = sort { $b->start <=> $a->start } @exons;
          }

          my $found_start = 0;
          my $found_end   = 0;
          my $phase       = 0;

          foreach my $exon (@exons) {
            if ($found_start && !$found_end) {
              $exon->phase($phase);
              $exon->end_phase(($exon->length + $exon->phase) % 3);
              $phase = $exon->end_phase;
            }
            if ($translation->start_Exon == $exon) {
              $exon->phase($phase);
        
              # Is this right?
              
              $exon->end_phase(($exon->length + $exon->phase) % 3);

              $phase       = $exon->end_phase;
              $found_start = 1;
            }
            if ($translation->end_Exon == $exon) {
              $found_end = 1;
            }
          }
        }
      }
    }
    eval {
    $gene->transform;

    foreach my $t (@{$gene->get_all_Transcripts}) {
        if (defined($t->translation)) {
           $t->translation->version(1);
        }
    }
    $db->get_GeneAdaptor->store($gene);
    #print $gene->toXMLString . "\n";
    };
    if ($@) {
       print "ERROR: Can't write gene [$@]\n";
    }  else {
       print "Written gene " . $gene->stable_id . "\n";
    }
  
    
  }
}

