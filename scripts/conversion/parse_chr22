#!/usr/local/bin/perl
use strict;
;

$| = 1;

#chr22   Pseudogene      exon    13930399        13931778        .       +       .       Sequence Em:AP000544.C22.1.mRNA
#chr22   Pseudogene      Sequence        13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1 ; Type "pseudogx1ene"; Description "Similar 
#to SW:P11940  Human POLYADENYLATE-BINDING PROTEIN 1 POLY(A) BINDING PROTEIN 1"; Locus "Em:AP000545.C22.1"
#chr22   Pseudogene      exon    13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1
#chr22   GD_mRNA exon    13953869        13954307        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA Sequence        13953869        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA ; Type "coding_gene"; Description "Similar to
# Wp:CE19906  and C2 genomic clone Em:AC002038"; Locus "Em:AP000546.C22.2"
#chr22   GD_CDS  CDS     13954092        13954307        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  Sequence        13954092        13959609        .       -       .       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  CDS     13958471        13958607        .       -       2       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13958471        13958607        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_CDS  CDS     13959501        13959609        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13959501        13959609        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13963439        13963588        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13964426        13964533        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13985077        13985252        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   Pseudogene      Sequence        14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1 ; Type "pseudogene"; Description "Similar 
#to Tr:P32391  ACTIN-LIKE PROTEIN 3"; Locus "Em:AP000546.C22.1"
#chr22   Pseudogene      exon    14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1
#chr22   GD_partial_mRNA exon    14028597        14028683        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA Sequence        14028597        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA ; Type "partial_gene"; Description "S
#imilar to Tr:O96017  Human PROTEIN KINASE."; Locus "Em:AP000547.C22.1"
#chr22   GD_partial_mRNA exon    14033456        14033536        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA exon    14034687        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_mRNA exon    14045473        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA

use Bio::Otter::AnnotatedGene;
use Bio::Otter::AnnotatedTranscript;
use Bio::Otter::TranscriptRemark;
use Bio::Otter::GeneRemark;
use Bio::Otter::Author;
use Bio::Otter::GeneInfo;
use Bio::Otter::TranscriptInfo;
use Bio::Otter::GeneName;
use Bio::Otter::TranscriptClass;
use Bio::Otter::Evidence;

use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::Transcript;

my %cds;
my %genes;
my %exons;
my %trans;

my $mapping_dir = "/nfs/acari/searle/progs/otter/scripts/convdata/chr22/22_to_havana_type_mapping";
my $type_conv_hash = read_22_to_havana_mappings($mapping_dir);

while (<>) {
  chomp;

  my @arr = split (' ', $_, 9);
  my $start  = $arr[3];
  my $end    = $arr[4];
  my $strand = $arr[6];

  my @arr2 = split (/\;/, $arr[8]);

  my %hashy;
  foreach my $str (@arr2) {
    my ($key, $val) = split (' ', $str, 2);

    # print "Found key $key $val\n";
    $key =~ s/ //g;
    $key =~ s/\"//g;
    $val =~ s/\"//g;
    if ($key ne "Description") {
      $val =~ s/^ +//;
      $val =~ s/ +$//;
      $key =~ s/\t//g;
      $val =~ s/\t//g;
    } else {
      $val =~ s/\t/ /g;
    }

    $hashy{$key} = $val;

    #print "Found key $key $val\n";

  }
  if ($arr[2] eq "Sequence") {
    my $id = $hashy{Sequence};

    $id =~ s/\.mRNA$//;

    $hashy{Sequence} = $id;

    # print "Id is now $id\n";
    $genes{$id}{$id}{start}  = $start;
    $genes{$id}{$id}{end}    = $end;
    $genes{$id}{$id}{strand} = $strand;

    if (!defined($genes{$id}{$id}{values}{Type})) {
      $genes{$id}{$id}{values} = \%hashy;
    }
  } elsif ($arr[2] eq "exon") {
    my $id = $hashy{Sequence};

    $id =~ s/\.mRNA$//;

    $hashy{Sequence} = $id;
    if (!defined($exons{$id}{$id}{exons})) {
      $exons{$id}{$id}{exons} = [];
    }
    my %exonhash;
    $exonhash{start}  = $start;
    $exonhash{end}    = $end;
    $exonhash{strand} = $strand;
    $exonhash{values} = \%hashy;
    push (@{ $exons{$id}{$id}{exons} }, \%exonhash);

  } elsif ($arr[2] eq "CDS") {

    if (!defined($cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds})) {
      $cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds} = [];
    }
    my %cdshash;
    $cdshash{start}  = $start;
    $cdshash{end}    = $end;
    $cdshash{strand} = $strand;
    $cdshash{values} = \%hashy;
    push (@{ $cds{ $hashy{Sequence} }{ $hashy{Sequence} }{cds} }, \%cdshash);
  }
}

my $author = new Bio::Otter::Author(
  -name  => 'Sanger',
  -email => 'vega@sanger.ac.uk'
);


foreach my $geneid (keys %genes) {
  # print STDERR "Gene id " . $geneid . "\n";

  foreach my $geneid2 (keys %{ $genes{$geneid} }) {
    # print STDERR "Gene id 2  $geneid2\n";

    my %values = %{ $genes{$geneid}{$geneid2}{values} };

    # foreach my $key (keys %values) {
    #   print STDERR "Gene Key $key " . $values{$key} . "\n";
    # }

    my $gene     = new Bio::Otter::AnnotatedGene;
    my $geneinfo = new Bio::Otter::GeneInfo;

    if (exists($type_conv_hash->{$geneid2})) {
      # print "Type = " . $type_conv_hash->{$geneid2} . "\n";
    } else { 
      die "Didn't find $geneid2\n";
    }
    $gene->gene_info($geneinfo);
    #$gene->type($values{'Type'});
    $gene->type($type_conv_hash->{$geneid2});
    if (defined($values{'Locus'}) && $values{'Locus'} ne $geneid) {
      #print "update gene_name set name='" . $values{'Locus'} . "' where name='" . $geneid . "';\n";
      $geneinfo->name(new Bio::Otter::GeneName(-name => $values{'Locus'}));
    } else {
      $geneinfo->name(new Bio::Otter::GeneName(-name => $geneid));
    }
    $geneinfo->author($author);

    #SMJS Added and then removed
    #$gene->stable_id($geneid);

    $values{Description} =~ s/\t/ /g;

    my @evidence;
    if ($values{Description} =~ /^Similar to /) {
      my @descwords = split /\s+/,$values{Description};
      # Remove full stop at end
      $descwords[$#descwords] =~ s/\.$//;
      foreach my $word (@descwords) {
        if ( $word =~ /^..:[A-Z][0-9][0-9][0-9][0-9][0-9]$/ ||
             $word =~ /^..:[A-Z][0-9][A-Z][A-Z][0-9][0-9]$/) {
          # print "Evidence: $word looks like an identifier\n";
          push @evidence,(new Bio::Otter::Evidence(-name => $word, -type => 'Protein'));
          
        } elsif ( $word =~ /^A[A-Z][0-9][0-9][0-9][0-9][0-9][0-9]/ ||
                  $word =~ /^..:[A-Z][0-9][0-9][0-9][0-9][0-9][0-9]$/) {
          # print "DNA Evidence: $word looks like an identifier\n";
          push @evidence,(new Bio::Otter::Evidence(-name => $word, -type => 'cDNA'));
        }
      }
    }

    my $remark = new Bio::Otter::GeneRemark(-remark => $values{Description});
    $geneinfo->remark($remark);

    my @tranids = keys(%{ $exons{$geneid} });

    foreach my $tranid (@tranids) {

      my $tran     = new Bio::Otter::AnnotatedTranscript;
      my $traninfo = new Bio::Otter::TranscriptInfo;
 
      foreach my $evi (@evidence) {
        $traninfo->evidence($evi);
      }

      $gene->add_Transcript($tran);

      $tran->transcript_info($traninfo);
      $traninfo->name($tranid);
      $traninfo->author($author);

      # $tran->stable_id($tranid);

      my %exhash = %{ $exons{$geneid}{$tranid} };
#       foreach my $key (keys %exhash) {
#         print STDERR "Key $key " . $exhash{$key} . "\n";
#       }
      my @exons = @{ $exons{$geneid}{$tranid}{exons} };

      my %evidence;

      foreach my $exon (@exons) {
        my $newexon = new Bio::EnsEMBL::Exon(
          -start  => $exon->{start},
          -end    => $exon->{end},
          -strand => $exon->{strand},
        );

        $tran->add_Exon($newexon);
        $newexon->phase(-1);

        # foreach my $key (keys %{ $exon->{values} }) {
        #   print STDERR "Exon value key $key " . $exon->{values}{$key} . "\n";
        # }
      }

#      foreach my $ev (keys %evidence) {
#        my $evidence = new Bio::Otter::Evidence(name => $ev, -type => 'EST');
#        print STDERR "Adding evidence $ev\n";
#        $traninfo->evidence($evidence);
#      }

      # Finally the CDS lines
      # There is only one cds - we have to infer which transcript it belongs to 
      # from the name

      my @tmp = keys(%{ $cds{$geneid} });

      # print STDERR "CDS tmp [$tranid] @tmp\n";

      if (scalar(@tmp) == 1) {
        my $tmpid = $tmp[0];

        # print STDERR "Ids [$tmpid][$tranid]\n";
        if ($tmpid eq $tranid) {
          my @cdsexons = @{ $cds{$geneid}{$tmpid}{cds} };
          # print STDERR "id [$tmpid][$tranid]\n";
          my $mincds = -1;
          my $maxcds = -1;
          foreach my $cdsex (@cdsexons) {
            if ($mincds == -1) {
              $mincds = $cdsex->{start};
            }
            if ($maxcds == -1) {
              $maxcds = $cdsex->{end};
            }
            if ($cdsex->{start} < $mincds) {
              $mincds = $cdsex->{start};
            }
            if ($cdsex->{end} > $maxcds) {
              $maxcds = $cdsex->{end};
            }
            # print STDERR "exon "
            #  . $cdsex->{start} . " "
            #  . $cdsex->{end} . " "
            #  . $cdsex->{strand} . "\n";
          }
          # print STDERR "Min / max " . $mincds . " " . $maxcds . "\n";

          my $translation = new Bio::EnsEMBL::Translation;
          $tran->translation($translation);
          my @exons = @{ $tran->get_all_Exons };
          foreach my $ex (@exons) {

            if ($mincds >= $ex->start && $mincds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->start_Exon($ex);
                $translation->start($mincds - $ex->start + 1);
              } else {
                $translation->end_Exon($ex);
                $translation->end($ex->end - $mincds + 1);
              }
            }
            if ($maxcds >= $ex->start && $maxcds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->end_Exon($ex);
                $translation->end($maxcds - $ex->start + 1);
              } else {
                $translation->start_Exon($ex);
                $translation->start($ex->end - $maxcds + 1);
              }
            }
          }

          # Finally the phase
          if ($exons[0]->strand == 1) {
            @exons = sort { $a->start <=> $b->start } @exons;
          } else {
            @exons = sort { $b->start <=> $a->start } @exons;
          }

          my $found_start = 0;
          my $found_end   = 0;
          my $phase       = 0;

          foreach my $exon (@exons) {
            if ($found_start && !$found_end) {
              $exon->phase($phase);
              $exon->end_phase(($exon->length + $exon->phase) % 3);
              $phase = $exon->end_phase;
            }
            if ($translation->start_Exon == $exon) {
              $exon->phase($phase);
        
              # Is this right?
              
              #$exon->end_phase(($exon->length + $exon->phase) % 3);
              #Changed from exon->length
              $exon->end_phase(
                (($exon->length - $translation->start + 1) + $exon->phase) % 3);

              $phase       = $exon->end_phase;
              $found_start = 1;
            }
            if ($translation->end_Exon == $exon) {
              $found_end = 1;
            }
          }
        }
      }
      if ($gene->type =~ /seudogene/) {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "Pseudogene"));
      } elsif ($tran->translation) {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "supported"));
      } else {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "supported_mRNA"));
      }
    }

    print $gene->toXMLString . "\n";
  }
}

sub read_22_to_havana_mappings {
  my ($dir) = @_;

  my %typehash;

  foreach my $file (qw(HUMACE-Known HUMACE-Novel_Transcript HUMACE-Putative
                       HUMACE-Novel_CDS HUMACE-Pseudogene)) {
    my $filename = "$dir/$file";
    my $type = $file;
    $type =~ s/HUMACE-//;
    if (! -e $filename) {
      die "Couldn't open mapping file $filename\n";
    }
    open FPMAP,"<$filename" or die "Couldn't open mapping file $filename";
    while (<FPMAP>) {
      if (/Sequence : \"(.*)\"/) {
        my $id = $1;
        $id =~ s/\.mRNA$//;
        $typehash{$id} = $type;
      }
    }
    close FPMAP;
  }
 
  return \%typehash;
}
