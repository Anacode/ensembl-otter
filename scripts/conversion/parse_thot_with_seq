#!/usr/local/bin/perl
# spliced_EST [BG221795]"; locus_id "undef"; alt_nb "1";
#K14_THOT GENOSCOPE exon 113860 114022 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_1"; type "Modele_Propose_f_M2";
#K14_THOT GENOSCOPE exon 114517 114942 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_1"; type "Modele_Propose_f_M2";
#K14_THOT GENOSCOPE cds 113860 114022 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_1_1"; type "CDS_f";
#K14_THOT GENOSCOPE cds 114517 114684 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_1_1"; type "CDS_f";
#K14_THOT GENOSCOPE exon 113860 114022 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_2"; type "Transcrit_f"; AC "BG221795";
#K14_THOT GENOSCOPE exon 114517 114942 . + . gene_id "K14_THOT_1"; transcript_id "K14_THOT_1_2"; type "Transcrit_f"; AC "BG221795";
#K14_THOT GENOSCOPE gene 135677 176269 . - . gene_id "K14_THOT_2"; transcript_id "K14_THOT_2_0"; type "Top_Modele_r"; gene_category "Pseudogene"; description "Pseudogene for 
#K14_THOT GENOSCOPE exon 135677 136473 . - . gene_id "K14_THOT_2"; transcript_id "K14_THOT_2_1"; type "Modele_Propose_r_M2";
#K14_THOT GENOSCOPE exon 151875 151951 . - . gene_id "K14_THOT_2"; transcript_id "K14_THOT_2_1"; type "Modele_Propose_r_M2";
#K14_THOT GENOSCOPE exon 152636 152834 . - . gene_id "K14_THOT_2"; transcript_id "K14_THOT_2_1"; type "Modele_Propose_r_M2";

use strict;
;

$| = 1;

use Bio::Otter::AnnotatedGene;
use Bio::Otter::AnnotatedTranscript;
use Bio::Otter::TranscriptRemark;
use Bio::Otter::GeneRemark;
use Bio::Otter::Author;
use Bio::Otter::GeneInfo;
use Bio::Otter::TranscriptInfo;
use Bio::Otter::GeneName;
use Bio::Otter::TranscriptClass;
use Bio::Otter::Evidence;

use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::Transcript;

use Bio::EnsEMBL::RawContig;

use Getopt::Long;

my $gtffile = undef;
my $seqfile = undef;
my $sumfile = undef;

$| = 1;

&GetOptions(
  'seqfile:s' => \$seqfile,
  'gtffile:s' => \$gtffile,
  'sumfile:s' => \$sumfile,
);

open FPSEQ, "$seqfile" or die "Failed opening $seqfile";
open FPGTF, "$gtffile" or die "Failed opening $gtffile";

if (defined($sumfile)) {
  open FPSUM, "$sumfile" or die "Failed opening $sumfile";
}

my $seqstr;
my $header = <FPSEQ>;
print "Got header line $header\n";
while (<FPSEQ>) {
  chomp;
  $seqstr .= $_;
}
my $contig = new Bio::EnsEMBL::RawContig;

$contig->name($seqfile . "_seq");
$contig->embl_offset(1);
$contig->length(length($seqstr));
$contig->seq($seqstr);

my %sumhash;
if (defined($sumfile)) {
  while (<FPSUM>) {
    my @words = split;
    if (scalar(@words) != 8) {
      die "Failed reading summary file\n";
    }
    my $strand = $words[0];
    $strand =~ s/.*_//;
    $sumhash{ $words[1] . "_" . $words[2] . "_" . $strand } = $_;
  }
}

my %cds;
my %genes;
my %exons;
my %trans;

my %type_hash;
$type_hash{"KNOWN GENE"} = "Known";
$type_hash{"KNOWN SEGMENT"} = "Ig_Segment";
$type_hash{"NOVEL GENE"} = "Novel_CDS";
$type_hash{"NOVEL TRANSCRIPT"} = "Novel_Transcript";
$type_hash{"PREDICTED GENE"} = "Predicted_Gene";
$type_hash{"PSEUDOGENE SEGMENT"} = "Ig_Pseudogene_Segment";
$type_hash{"PUTATIVE GENE"} = "Putative";
$type_hash{Pseudogene} = "Pseudogene";

while (<FPGTF>) {
  chomp;

  my @arr = split (' ', $_, 9);
  my $start  = $arr[3];
  my $end    = $arr[4];
  my $strand = $arr[6];

  my @arr2 = split (/\;/, $arr[8]);

  my %hashy;
  foreach my $str (@arr2) {
    my ($key, $val) = split (' ', $str, 2);
    $key =~ s/ //g;
    $key =~ s/\"//g;
    $val =~ s/\"//g;

    $hashy{$key} = $val;
  }
  if ($arr[2] eq "gene") {
    $genes{ $hashy{gene_id} }{ $hashy{transcript_id} }{start}  = $start;
    $genes{ $hashy{gene_id} }{ $hashy{transcript_id} }{end}    = $end;
    $genes{ $hashy{gene_id} }{ $hashy{transcript_id} }{strand} = $strand;
    $genes{ $hashy{gene_id} }{ $hashy{transcript_id} }{values} = \%hashy;
  } elsif ($arr[2] eq "exon") {
    if (!defined($exons{ $hashy{gene_id} }{ $hashy{transcript_id} }{exons})) {
      $exons{ $hashy{gene_id} }{ $hashy{transcript_id} }{exons} = [];
    }
    my %exonhash;
    $exonhash{start}  = $start;
    $exonhash{end}    = $end;
    $exonhash{strand} = $strand;
    $exonhash{values} = \%hashy;
    push (@{ $exons{ $hashy{gene_id} }{ $hashy{transcript_id} }{exons} },
      \%exonhash);

  } elsif ($arr[2] eq "cds") {

    if (!defined($cds{ $hashy{gene_id} }{ $hashy{transcript_id} }{cds})) {
      $cds{ $hashy{gene_id} }{ $hashy{transcript_id} }{cds} = [];
    }
    my %cdshash;
    $cdshash{start}  = $start;
    $cdshash{end}    = $end;
    $cdshash{strand} = $strand;
    $cdshash{values} = \%hashy;
    push (@{ $cds{ $hashy{gene_id} }{ $hashy{transcript_id} }{cds} },
      \%cdshash);

  }

}

my $author = new Bio::Otter::Author(
  -name  => 'Genoscope',
  -email => 'ralph@genoscope.cns.fr',
);

foreach my $geneid (keys %genes) {
  print "Gene id " . $geneid . "\n";

  foreach my $geneid2 (keys %{ $genes{$geneid} }) {
    print "Gene id  $geneid2\n";

    my %values = %{ $genes{$geneid}{$geneid2}{values} };

    foreach my $key (keys %values) {
      print "Gene Key $key " . $values{$key} . "\n";
    }

    my $gene     = new Bio::Otter::AnnotatedGene;
    my $geneinfo = new Bio::Otter::GeneInfo;

    $gene->gene_info($geneinfo);
    $gene->type($type_hash{$values{'gene_category'}});
    $geneinfo->name(new Bio::Otter::GeneName(-name => $geneid));
    $geneinfo->author($author);

    $gene->stable_id($geneid);

    my $remark = new Bio::Otter::GeneRemark(-remark => $values{description});
    $geneinfo->remark($remark);

    my $cds_transcript = undef;

    my @tranids = keys(%{ $exons{$geneid} });

    foreach my $tranid (@tranids) {

      my $tran     = new Bio::Otter::AnnotatedTranscript;
      my $traninfo = new Bio::Otter::TranscriptInfo;

      $gene->add_Transcript($tran);

      $tran->transcript_info($traninfo);
      $traninfo->class(
        new Bio::Otter::TranscriptClass(-name => $type_hash{$values{'gene_category'}}));
      $traninfo->name($tranid);
      $traninfo->author($author);

      $tran->stable_id($tranid);

      my %exhash = %{ $exons{$geneid}{$tranid} };
      foreach my $key (keys %exhash) {
        print "Key $key " . $exhash{$key} . "\n";
      }
      my @exons = @{ $exons{$geneid}{$tranid}{exons} };

      my %evidence;

      foreach my $exon (@exons) {
        my $newexon = new Bio::EnsEMBL::Exon(
          -start  => $exon->{start},
          -end    => $exon->{end},
          -strand => $exon->{strand},
        );
        $newexon->contig($contig);

        $tran->add_Exon($newexon);
        $newexon->phase(-1);
        if (defined($exon->{values}{AC})) {
          if ($exon->{values}{AC} ne "NO_AC" && 
              $exon->{values}{AC} ne "undef") {
            my $acc = $exon->{values}{AC};
            # print "found evidence $acc\n";
            $evidence{$acc} = 1;
          }
        }
        foreach my $key (keys %{ $exon->{values} }) {

          #print "Exon value key $key " . $exon->{values}{$key} . "\n";
        }
      }
      foreach my $ev (keys %evidence) {

        # Was type genoscope
        my $evidence =
          new Bio::Otter::Evidence(-name => $ev, -type => 'Genomic');
        # print "Adding evidence $ev\n";
        $traninfo->evidence($evidence);
      }

      # Finally the CDS lines
      # There is only one cds - we have to infer which transcript it belongs to 
      # from the name

      my @tmp = keys(%{ $cds{$geneid} });

      print "CDS tmp [$tranid] @tmp\n";

      if (scalar(@tmp) == 1) {
        my $tmpid = $tmp[0];

        print "Ids [$tmpid][$tranid]\n";
        if ($tmpid eq "${tranid}_1") {
          my @cdsexons = @{ $cds{$geneid}{$tmpid}{cds} };
          print "id [$tmpid][$tranid]\n";
          my $mincds = -1;
          my $maxcds = -1;
          foreach my $cdsex (@cdsexons) {
            if ($mincds == -1) {
              $mincds = $cdsex->{start};
            }
            if ($maxcds == -1) {
              $maxcds = $cdsex->{end};
            }
            if ($cdsex->{start} < $mincds) {
              $mincds = $cdsex->{start};
            }
            if ($cdsex->{end} > $maxcds) {
              $maxcds = $cdsex->{end};
            }
            # print "exon "
            #   . $cdsex->{start} . " "
            #   . $cdsex->{end} . " "
            #  . $cdsex->{strand} . "\n";
          }
          print "Min / max " . $mincds . " " . $maxcds . "\n";

          my $translation = new Bio::EnsEMBL::Translation;
          $tran->translation($translation);
          my @exons = @{ $tran->get_all_Exons };
          foreach my $ex (@exons) {

            if ($mincds >= $ex->start && $mincds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->start_Exon($ex);
                $translation->start($mincds - $ex->start + 1);
              } else {
                $translation->end_Exon($ex);
                $translation->end($ex->end - $mincds + 1);
              }
            }
            if ($maxcds >= $ex->start && $maxcds <= $ex->end) {

              if ($ex->strand == 1) {
                $translation->end_Exon($ex);
                $translation->end($maxcds - $ex->start + 1);
              } else {
                $translation->start_Exon($ex);
                $translation->start($ex->end - $maxcds + 1);
              }
            }
          }

          # Finally the phase
          if ($exons[0]->strand == 1) {
            @exons = sort { $a->start <=> $b->start } @exons;
          } else {
            @exons = sort { $b->start <=> $a->start } @exons;
          }

          my $found_start = 0;
          my $found_end   = 0;
          my $phase       = 0;

          # Otter expects all translations to start in phase 0 so
          # have to modify start to cater for incomplete codons
          # at start of translation
          my $frame = get_initial_frame($tran);
          if ($frame != 0) {
            $translation->start($translation->start + $frame);
          }

          foreach my $exon (@exons) {
            if ($found_start && !$found_end) {
              $exon->phase($phase);
              $exon->end_phase(($exon->length + $exon->phase) % 3);
              $phase = $exon->end_phase;
            }
            if ($translation->start_Exon == $exon) {
              $exon->phase($phase);

              #Changed from exon->length
              $exon->end_phase(
                (($exon->length - $translation->start + 1) + $exon->phase) % 3);
              $phase       = $exon->end_phase;
              $found_start = 1;
            }
            if ($translation->end_Exon == $exon) {
              $found_end = 1;
            }
          }
          if ($tran->translate->seq =~ /\*/) {
            print "Failed translating $tran->stable_id after phase setting\n";
          }
          $cds_transcript = $tran;
        }
      }
      if ($gene->type =~ /seudogene/) {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "Pseudogene"));
      } elsif (defined($cds_transcript)) {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "supported"));
      } else {
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => "supported_mRNA"));
      }

    }

    my $sumkey = $gene->start . "_" . $gene->end . "_" . ($gene->strand == 1 ? "f" : "r");
    if (!exists($sumhash{$sumkey})) {
      if (defined($sumfile)) {
        print "NOTE NOTE NOTE: Failed finding in summary hash\n";
      }
    } else {
      print $sumhash{$sumkey} . "\n";
      if (defined($cds_transcript)) {
        my @words = split /\s+/,$sumhash{$sumkey};
        print "Words 4 = " . $words[4] . "\n";
        if ($words[4] eq "no_start") {
          $cds_transcript->transcript_info->cds_start_not_found(1);
        }
      }
    }
    print $gene->toXMLString . "\n";
  }
}

#Handling for incomplete translations (don't always start on a codon boundary)
sub get_initial_frame {
  my ($trans) = @_;

  $trans->sort;

  #Fudge end phase
  foreach my $exon (@{ $trans->get_all_Exons }) {
    $exon->end_phase(0);
  }

  print "Trying to find translating frame\n";
  my $cdna = new Bio::Seq(-seq => $trans->translateable_seq);

  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    if ($pepseq !~ /\*/) {
      print "Frame $frame does translate\n";

      #      return (3-$frame)%3;
      return $frame;
    }
  }
  print "Failed to translate transcript in any phase\n";
  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    print "Pepseq frame $frame = " . $pepseq . "\n";
  }
  return 0;
}
