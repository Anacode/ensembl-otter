#!/usr/local/bin/perl

use strict;

$| = 1;

use Bio::Otter::AnnotatedGene;
use Bio::Otter::AnnotatedTranscript;
use Bio::Otter::Author;
use Bio::Otter::Evidence;
use Bio::Otter::GeneInfo;
use Bio::Otter::GeneName;
use Bio::Otter::GeneRemark;
use Bio::Otter::GeneSynonym;
use Bio::Otter::TranscriptClass;
use Bio::Otter::TranscriptInfo;
use Bio::Otter::TranscriptRemark;

use Bio::Otter::DBSQL::DBAdaptor;

use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::Transcript;
use Bio::EnsEMBL::Clone;
use Bio::EnsEMBL::RawContig;

use Bio::SeqIO;

use Getopt::Long;

my $emblfile      = undef;
my $host          = 'localhost';
my $user          = 'root';
my $pass          = '';
my $port          = 3306;
my $dbname        = 'scoe';
my $gene_type     = 'Known';
my $assembly_type = 'PANTS';
my $name_prefix   = 'scoe';
my $contig_size   = 500000;

&GetOptions(
            'emblfile:s'     => \$emblfile,
            'dbname:s'       => \$dbname,
            'user:s'         => \$user,
            'pass:s'         => \$pass,
            'port:n'         => \$port,
            'host:s'         => \$host,
            'assemblytype:s' => \$assembly_type,
            'genetype:s'     => \$gene_type,
            'nameprefix:s'   => \$name_prefix,
            'contigsize:n'   => \$contig_size,
            );

my $db = new Bio::Otter::DBSQL::DBAdaptor(
  -host   => $host,
  -user   => $user,
  -pass   => $pass,
  -port   => $port,
  -dbname => $dbname,
);

my $analysis = new Bio::EnsEMBL::Analysis(-logic_name => 'curated');

eval {
  my $sth = $db->prepare("insert into meta values(\\N,\"assembly.default\",\"$assembly_type\")");
  $sth->execute;
};
if ($@) {
  die "Failed doing meta table insert $@\n";
}

$db->assembly_type($assembly_type);

if (!defined($emblfile)) {
  print "Must give a filename\n";
  exit;
}

my $in  = Bio::SeqIO->new(-file => $emblfile , '-format' => 'EMBL');


my $author = new Bio::Otter::Author(
  -name  => 'SangerPants',
  -email => 'pants@sanger.ac.uk',
);

while ( my $seq = $in->next_seq() ) {
  
  my $slice = split_seq ($db, $seq, $contig_size, $name_prefix, $assembly_type);

  my @features = $seq->get_SeqFeatures(); # just top level

  foreach my $feat (@features) {
    if ($feat->primary_tag eq "CDS") {
      my @ids = $feat->get_tag_values('gene');
      my $geneid;
      my @synonyms;
      foreach my $curid (@ids) {
        if ($curid =~ /^SCO[0-9][0-9][0-9][0-9]/) {
          $geneid = $curid;
        } else {
          push @synonyms, new Bio::Otter::GeneSynonym(-name => $curid);
        }
      }

      print "Gene ID = $geneid\n";

      my $gene     = new Bio::Otter::AnnotatedGene;
      $gene->analysis($analysis);
      my $geneinfo = new Bio::Otter::GeneInfo(-synonym => \@synonyms);
  
      $gene->gene_info($geneinfo);
      $gene->type('pants');
      $geneinfo->name(new Bio::Otter::GeneName(-name => $geneid));
      $geneinfo->author($author);


      my $time = time;
  
      $gene->stable_id($geneid);
      $gene->created($time);
      $gene->modified($time);
      $gene->version(1);

      my @notes = $feat->get_tag_values('note');

      my $remark = new Bio::Otter::GeneRemark(-remark => $notes[0]);
      $geneinfo->remark($remark);
  
      my $tranid = $geneid;
      my $tran     = new Bio::Otter::AnnotatedTranscript;
      my $traninfo = new Bio::Otter::TranscriptInfo;

      $gene->add_Transcript($tran);

      $tran->transcript_info($traninfo);
      $traninfo->name($tranid);
      $traninfo->author($author);

      $tran->stable_id($tranid);
      $tran->created($time);
      $tran->modified($time);
      $tran->version(1);

      my @exs = $feat->get_SeqFeatures;
      if (scalar(@exs)) {
        print "Has subfeatures\n";
      } else {
        @exs = ($feat);
      }
     
      @exs = ($feat);
      foreach my $exon (@exs) {
        my $newexon = new Bio::EnsEMBL::Exon(
          -start  => $exon->start,
          -end    => $exon->end,
          -strand => $exon->strand,
        );
        $newexon->contig($slice);
        print "Adding exon $newexon with contig $slice\n";

        $tran->add_Exon($newexon);
        $newexon->phase(-1);
      }
      my @exons = @{ $tran->get_all_Exons };

      # Finally the phase
      if ($exons[0]->strand == 1) {
        @exons = sort { $a->start <=> $b->start } @exons;
      } else {
        @exons = sort { $b->start <=> $a->start } @exons;
      }

      if ($feat->has_tag('pseudo')) {
        print "PSEUDOGENE\n";
        $traninfo->class(
          new Bio::Otter::TranscriptClass(-name => 'Pseudogene'));
        foreach my $exon (@exons) {
          $exon->phase(-1);
          $exon->end_phase(-1);
        }
        
      } else {
        if ($feat->has_tag('product')) {
          my @products = $feat->get_tag_values('product');
          my $hypothetical = 0;
          my $putative = 0;
        
          foreach my $product (@products) {
            print "product = $product\n";
            $traninfo->remark(
                new Bio::Otter::TranscriptRemark(-remark => "product-- " .$product));
            if ($product =~ /ypothetical/){
              $hypothetical = 1;
            } elsif ($product =~ /putative/) {
              $putative = 1;
            }
          }
          if ($hypothetical) {
            print "Novel\n";
            $traninfo->class(
              new Bio::Otter::TranscriptClass(-name => 'NovelCDS'));
          } elsif ($putative) {
            print "Putative\n";
            $traninfo->class(
              new Bio::Otter::TranscriptClass(-name => 'Putative'));
          } else {
            print "Known\n";
            $traninfo->class(
              new Bio::Otter::TranscriptClass(-name => 'Known'));
          }
        } else {
          print "WARNING: No product tag for $geneid\n";
          $traninfo->class(
            new Bio::Otter::TranscriptClass(-name => 'NovelCDS'));
        }

        my $translation = new Bio::EnsEMBL::Translation;
        $tran->translation($translation);
  
        my $found_start = 0;
        my $found_end   = 0;
        my $phase       = 0;
  
        $translation->start_Exon($exons[0]);
        $translation->start(1);
        $translation->end_Exon($exons[$#exons]);
        $translation->end($exons[$#exons]->length);
  
        # Otter expects all translations to start in phase 0 so
        # have to modify start to cater for incomplete codons
        # at start of translation
        my $frame = get_initial_frame($tran);
        if ($frame != 0) {
          $translation->start($translation->start + $frame);
          $traninfo->cds_start_not_found(1);
        }
  
  
        foreach my $exon (@exons) {
          if ($found_start && !$found_end) {
            $exon->phase($phase);
            $exon->end_phase(($exon->length + $exon->phase) % 3);
            $phase = $exon->end_phase;
          }
          if ($translation->start_Exon == $exon) {
            $exon->phase($phase);
  
            #Changed from exon->length
            $exon->end_phase(
              (($exon->length - $translation->start + 1) + $exon->phase) % 3);
            $phase       = $exon->end_phase;
            $found_start = 1;
          }
          if ($translation->end_Exon == $exon) {
            $found_end = 1;
          }
        }
        if ($tran->translate->seq =~ /\*/) {
          print "Failed translating $tran->stable_id after phase setting\n";
        }
      }
      $gene->transform;
      eval {
        $db->get_GeneAdaptor->store($gene);
      };
      if ($@) {
        print "Failed loading $geneid\n$@";
      }
    }
  }
}




#Handling for incomplete translations (don't always start on a codon boundary)
sub get_initial_frame {
  my ($trans) = @_;

  $trans->sort;

  #Fudge end phase
  foreach my $exon (@{ $trans->get_all_Exons }) {
    print $exon->seq->seq;
    print $exon->seq;
    $exon->end_phase(0);
  }

  print "Trying to find translating frame\n";
  my $cdna = new Bio::Seq(-seq => $trans->translateable_seq);

  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    if ($pepseq !~ /\*/) {
      print "Frame $frame does translate\n";

      return $frame;
    }
  }
  print "Failed to translate transcript in any phase\n";
  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    print "Pepseq frame $frame = " . $pepseq . "\n";
  }
  return 0;
}

{
  my $clone_idcount = 1;
  my $contig_idcount = 1;
  my $chr_idcount = 1;

  sub split_seq {
    my ($db, $seq, $split_size, $prefix, $assembly_type) = @_;
  
    my $len = $seq->length;

    my $chrid = "chr_" . $prefix . "_" . $chr_idcount++;

    my $chr_dbID;
    eval { 
      my $sth = $db->prepare("insert into chromosome set name=\"$chrid\", length=$len");
      $sth->execute;
      $chr_dbID = $sth->{'mysql_insertid'};
    };
    if (@$) {
      die "Failed adding chromosome $chrid";
    }


    print "contig_size = " . $split_size . "\n"; 
  
    for (my $start=1; $start<$len; $start+=$split_size) {
      my $end = $start + $split_size - 1;
  
      if ($end > $len) {
        $end = $len;
      }
      
      my $piece = $seq->subseq($start,$end);
  
      my $clone = new Bio::EnsEMBL::Clone();
    
      my $time = time;
    
      my $contigid = "contig_" . $prefix . "_" . $contig_idcount++;
      my $cloneid  = "clone_"  . $prefix . "_" . $clone_idcount++;
  
      $clone->id($cloneid);
      $clone->embl_id($cloneid);
      $clone->version(1);
      $clone->embl_version(1);
      $clone->htg_phase(-1);
      $clone->created($time);
      $clone->modified($time);
    
      # Create contig
    
      my $contig = new Bio::EnsEMBL::RawContig;
    
      $contig->name($contigid);
      $contig->clone($clone);
      $contig->embl_offset(1);
      $contig->length(length($piece));
      $contig->seq($piece);
    
      $clone->add_Contig($contig);
    
      $db->get_CloneAdaptor->store($clone);
  
      my $contig_len = $contig->length;
      my $contig_dbID = $contig->dbID;
      my $sth2 = $db->prepare( qq:
        insert into assembly(chromosome_id,
                             chr_start,
                             chr_end,
                             superctg_name,
                             superctg_start,
                             superctg_end,
                             superctg_ori,
                             contig_id,
                             contig_start,
                             contig_end,
                             contig_ori,
                             type)
                    values($chr_dbID,
                           $start,
                           $end,
                           "$contigid",
                           1,
                           $contig_len,
                           1,
                           $contig_dbID,
                           1,
                           $contig_len,
                           1,
                           "$assembly_type"
                         ):);
      # print $sth2->{Statement} . "\n";
      $sth2->execute;
    }
  
    my $slice = $db->get_SliceAdaptor->fetch_by_chr_name($chrid);
  
    return $slice;
  }
}
