#!/usr/bin/perl -w

### gtf2ensembl

use strict;
use Text::ParseWords 'quotewords';
use Bio::EnsEMBL::Gene;
use Bio::EnsEMBL::Transcript;
use Bio::EnsEMBL::Translation;
use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::DBSQL::DBAdaptor;

{
    my( $dba, $ana, $slice );
    {
        my $host        = 'localhost';
        my $db          = 'test_gtf';
        my $user        = 'root';
        my $pass        = undef;
        my $port        = 3322;
        my $chr_name    = '22';
        my $ana_name    = 'sanger_gene';
        my $sgp_type    = 'SANGER';
 
        $dba = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
            -DBNAME => $db,
            -HOST   => $host,
            -USER   => $user,
            -PASS   => $pass,
            );
        $dba->assembly_type($sgp_type);

        $slice = $dba->get_SliceAdaptor->fetch_by_chr_name($chr_name);

        $ana = new Bio::EnsEMBL::Analysis(-logic_name => 'curated');

        $dba->get_AnalysisAdaptor->store($ana);
    }

    print "Slice " . @{$slice->get_tiling_path} . "\n";
    my $gtf = parse_gtf(\*ARGV);

    write_ens_genes($gtf, $dba, $slice, $ana, 'Chr22-');
}

sub parse_gtf {
    my( $fh ) = @_;

    # GTF -> EnsEMBL phase convention map
    my %gtf_ens_phase = (
         0  =>  0,
         1  =>  2,
         2  =>  1,
        '.' => -1,
        );

    # Parse the GTF file, and store its data in the hash $gtf
    my $gtf = {};
    my $genomic = undef;
    while (defined(my $line = <$fh>)) {
        next if $line =~ /^$/;
        next if $line =~ /^#/;
        chomp($line);
        my( $chr_name,
            $gene_type,
            $feature,
            $start,
            $end,
            $score,
            $strand,
            $phase,
            $group,
            ) = split(/\s+/, $line, 9);
        
        if (defined($genomic)) {
            die "More than 1 genomic sequence in GTF file '$genomic' and '$chr_name'"
                unless $genomic eq $chr_name;
        } else {
            $genomic = $chr_name;
        }
        
        # Put strand into EnsEMBL convention
        if ($strand eq '+') {
            $strand = 1;
        }
        elsif ($strand eq '-') {
            $strand = -1;
        }
        else {
            $strand = 0;
        }
        
        # Put the phase into the EnsEMBL convention
        $phase = $gtf_ens_phase{$phase};
        unless (defined $phase) {
            die "Illegal phase in: $line";
        }
        
        # Parse the group field
        # (Not technically correct, because can have 1 tag with
        # multiple values.)
        my $tag_val = {};
        foreach my $tv (grep $_, split /\s*;\s*/, $group) {
            my ($tag, $val) = quotewords('\s+', 0, $tv);
            $tag_val->{lc $tag} = $val;
        }
        
        # To debug group field parsing
        #while (my ($tag, $val) = each(%$tag_val)) {
        #    print "$tag\t", join(', ', map "[$_]", @$val), "\n";
        #}
        
        my $seq = $tag_val->{'sequence'}
            or die "No sequence for feature: $line\n";
        $seq =~ s/\.mRNA$//;

        $feature = lc $feature;
        if ($feature eq 'exon') {
            push(@{$gtf->{'exon'}{$seq}}, [$start, $end, $strand]);
        }
        elsif ($feature eq 'cds') {
            push(@{$gtf->{'cds'}{$seq}}, [$start, $end, $strand, $phase]);
        }
        elsif ($feature eq 'sequence') {
            if (my $gene = $tag_val->{'locus'}) {
                my $desc = $tag_val->{'description'};
                my $type = $tag_val->{'type'}
                    or die "No type for gene: $line\n";
                $gtf->{'gene'}{$type}{$gene}{$seq} = $desc || 'NONE';
            }
        }
        else {
            warn "Unknown feature '$feature'\n";
        }
    }
    
    return $gtf;
}

sub write_ens_genes {
    my( $gtf, $dba, $vc, $ana, $type_prefix ) = @_;

    my $time = time;
    my $gene_adaptor = $dba->get_GeneAdaptor;

    # Loop through each type of gene    
    foreach my $type (keys %{$gtf->{'gene'}}) {
        my $type_hash = $gtf->{'gene'}{$type};
        $type = "$type_prefix$type";
        
        # Loop through each gene
        foreach my $gene_name (keys %$type_hash) {
            print STDERR "\n$type\t$gene_name\n";
            my $gene_seq = $type_hash->{$gene_name};
            
            my $gene = Bio::EnsEMBL::Gene->new;
            $gene->stable_id($gene_name);
            $gene->version(1);
            $gene->created($time);
            $gene->modified($time);
            $gene->type($type);
            $gene->analysis($ana);
            
            # Loop through each transcript
          SUBSEQ: while (my ($seq_name, $desc) = each %$gene_seq) {
                printf STDERR "  %20s\t%-s\n", $seq_name, $desc;
                if ($desc ne 'NONE') {
                    $gene->description($desc);
                }
                
                my $tsct = Bio::EnsEMBL::Transcript->new;
                $tsct->stable_id($seq_name);
                
                $tsct->version(1);
                $tsct->created($time);
                $tsct->modified($time);

                # Get the CDS and exon data for this transcript
                my @mrna = sort {$a->[0] <=> $b->[0]} @{$gtf->{'exon'}{$seq_name}};
                my( @cds );
                if (my $c = $gtf->{'cds'}{$seq_name}) {
                    @cds = sort {$a->[0] <=> $b->[0]} @$c;
                }
                
                # Get strand from first exon, and check is
                # the same for all the rest.
                my $strand = $mrna[0][2];
                my @all_ex = (@mrna, @cds);
                for (my $i = 1; $i < @all_ex; $i++) {
                    my $this_strand = $all_ex[$i][2];
                    if ($strand != $this_strand) {
                        print STDERR "ERROR: Multiple strands in '$seq_name'\n";
                        next SUBSEQ;
                    }
                }
                
                # Flip arrays into translation order if on opposite strands
                if ($strand == -1) {
                    @mrna = reverse @mrna;
                    @cds  = reverse @cds;
                }
                
                # Make an exon for each entry in the mrna array
                my( @exons );
                foreach my $m (@mrna) {
                    my $start = $m->[0];
                    my $end   = $m->[1];
                    
                    my $ex = Bio::EnsEMBL::Exon->new;
                    $ex->version(1);
                    $ex->created($time);
                    $ex->modified($time);
                    $ex->start($start);
                    $ex->end($end);
                    $ex->strand($strand);
                    $ex->phase(-1);
                    $ex->end_phase(-1);
                    $ex->contig($vc);    # Shouldn't attach_seq do this?
                    $ex->attach_seq($vc);
                    $ex->adaptor($dba->get_ExonAdaptor); 
                    push(@exons, $ex);
                }
                
                # Make Translation and set exon phases if there is CDS info
                if (@cds) {
                    my $tsl = Bio::EnsEMBL::Translation->new;
                    $tsl->stable_id($seq_name);
                    $tsl->version(1);
                    my $j = 0;  # Points to first CDS segement
                    my $last_translating_exon = undef;
                    for (my $i = 0; $i < @exons; $i++) {
                        my $ex = $exons[$i];
                        my $cd = $cds[$j];
                        
                        # Does this overlap the next CDS segment?
                        if ($ex->start <= $cd->[1] and $ex->end >= $cd->[0]) {
                        
                            # Add the phase from the CDS
                            $ex->phase($cd->[3]);
                            $ex->end_phase(($ex->length + $ex->phase)%3);
                            $ex = get_unique_exon_with_stable_id($gene_name, $ex);
                        
                            my $pos = $strand == 1 ? $cd->[0] : $cd->[1];
                            $tsl->start_Exon($ex);
                            $tsl->start(exon_coord($ex, $pos));
                            
                            $last_translating_exon = $ex;
                            
                            # Move pointer unless this is the last CDS segement
                            $j++ unless $j == $#cds;
                        } else {
                            # Non-coding exon
                            $ex = get_unique_exon_with_stable_id($gene_name, $ex);
                        }
                        
                        $exons[$i] = $ex;
                        
                        ### FIXME: Extra checks for CDS and exon border mismatches
                    }
                                        
                    if ($j != $#cds) {
                        my $found = $j + 1;
                        my $cds_count = @cds;
                        print STDERR "ERROR: didn't match all CDS segements to exons (found $found out of $cds_count)";
                        next SUBSEQ;
                    } else {
                        my $cd = $cds[$j];
                        $tsl->end_Exon($last_translating_exon);
                        my $pos = $strand == 1 ? $cd->[1] : $cd->[0];
                        $tsl->end(exon_coord($last_translating_exon, $pos));
                    }
                    
                    $tsct->translation($tsl);
                } else {
                    # Non-coding transcript
                    for (my $i = 0; $i < @exons; $i++) {
                        $exons[$i] = get_unique_exon_with_stable_id($gene_name, $exons[$i]);
                    }
                }
    
                # Add each exon to the transcript                
                foreach my $ex (@exons) {
                    $tsct->add_Exon($ex);
                }
                
                # Add this transcript to the Gene
                $gene->add_Transcript($tsct);
            }
            
            # Write the gene
            eval{
                remap_and_write_gene($dba, $vc, $gene);
            };
            if ($@) {
                print STDERR "ERROR: Failed to write gene: $@";
            } else {
                print STDERR "Written gene " . $gene->stable_id . "\n";
            }
        }
    }
}

BEGIN {
    my $current_gene = '';
    my %current_exons = ();

    sub get_unique_exon_with_stable_id {
        my( $gene_name, $ex ) = @_;
        
        # Empty hash if we have a new gene
        if ($gene_name ne $current_gene) {
            $current_gene = $gene_name;
            %current_exons = ();
        }
        
        my $key = exon_hash_key($ex);
        if (my $seen_exon = $current_exons{$key}) {
            return $seen_exon;
        } else {
            my $n = sprintf "%03d", 1 + scalar(keys %current_exons);
            $ex->stable_id("$gene_name-$n");
            $current_exons{$key} = $ex;
            return $ex;
        }
    }
}

sub exon_hash_key {
    my( $exon ) = @_;
    
    return  join('-'
        , $exon->strand
        , $exon->start
        , $exon->end
        , $exon->phase
        );
;
}

sub remap_and_write_gene {
    my( $dba, $vc, $gene ) = @_;

    $gene->transform;
    $dba->get_GeneAdaptor->store($gene);
}

# Returns genomic position in exon coordinates
sub exon_coord {
    my( $exon, $coord ) = @_;
    
    if ($exon->strand == 1) {
        my $start = $exon->start;
        return $coord - $start + 1;
    } else {
        my $end = $exon->end;
        return $end - $coord + 1;
    }    
}

__END__

=head1 NAME - gtf2ensembl

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

