#!/usr/bin/perl

use strict;

use Bio::Otter::AnnotatedGene;
use Bio::Otter::AnnotatedTranscript;
use Bio::Otter::TranscriptRemark;
use Bio::Otter::GeneRemark;
use Bio::Otter::Author;
use Bio::Otter::GeneInfo;
use Bio::Otter::TranscriptInfo;
use Bio::Otter::GeneName;
use Bio::Otter::TranscriptClass;
use Bio::Otter::Evidence;

use Bio::EnsEMBL::SimpleFeature;

$| = 1;

#chr22   Pseudogene      exon    13930399        13931778        .       +       .       Sequence Em:AP000544.C22.1.mRNA
#chr22   Pseudogene      Sequence        13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1 ; Type "pseudogx1ene"; Description "Similar 
#to SW:P11940  Human POLYADENYLATE-BINDING PROTEIN 1 POLY(A) BINDING PROTEIN 1"; Locus "Em:AP000545.C22.1"
#chr22   Pseudogene      exon    13949672        13951607        .       +       .       Sequence Em:AP000545.C22.1
#chr22   GD_mRNA exon    13953869        13954307        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA Sequence        13953869        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA ; Type "coding_gene"; Description "Similar to
# Wp:CE19906  and C2 genomic clone Em:AC002038"; Locus "Em:AP000546.C22.2"
#chr22   GD_CDS  CDS     13954092        13954307        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  Sequence        13954092        13959609        .       -       .       Sequence Em:AP000546.C22.2
#chr22   GD_CDS  CDS     13958471        13958607        .       -       2       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13958471        13958607        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_CDS  CDS     13959501        13959609        .       -       0       Sequence Em:AP000546.C22.2
#chr22   GD_mRNA exon    13959501        13959609        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13963439        13963588        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13964426        13964533        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   GD_mRNA exon    13985077        13985252        .       -       .       Sequence Em:AP000546.C22.2.mRNA
#chr22   Pseudogene      Sequence        14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1 ; Type "pseudogene"; Description "Similar 
#to Tr:P32391  ACTIN-LIKE PROTEIN 3"; Locus "Em:AP000546.C22.1"
#chr22   Pseudogene      exon    14011987        14013509        .       +       .       Sequence Em:AP000546.C22.1
#chr22   GD_partial_mRNA exon    14028597        14028683        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA Sequence        14028597        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA ; Type "partial_gene"; Description "S
#imilar to Tr:O96017  Human PROTEIN KINASE."; Locus "Em:AP000547.C22.1"
#chr22   GD_partial_mRNA exon    14033456        14033536        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_partial_mRNA exon    14034687        14034930        .       +       .       Sequence Em:AP000547.C22.1.mRNA
#chr22   GD_mRNA exon    14045473        14045587        .       -       .       Sequence Em:AP000546.C22.2.mRNA

#AL773603.1      sim4    CDS     47650   47696   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "6"; transcript_start "1"; transcript_end "47"; transcript_length "543";
#AL773603.1      sim4    CDS     51279   51325   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "5"; transcript_start "48"; transcript_end "94"; transcript_length "543";
#AL773603.1      sim4    CDS     52262   52433   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "4"; transcript_start "95"; transcript_end "266"; transcript_length "543";
#AL773603.1      sim4    CDS     57232   57340   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "3"; transcript_start "267"; transcript_end "375"; transcript_length "543";
#AL773603.1      sim4    CDS     61464   61516   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "2"; transcript_start "376"; transcript_end "428"; transcript_length "543";
#AL773603.1      sim4    CDS     69571   69685   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "1"; transcript_start "429"; transcript_end "543"; transcript_length "543"; match_strand "-"; exon_strand ".";
#AL773603.1      sim4    exon    45667   47696   99      -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "6"; transcript_start "1"; transcript_end "2028"; transcript_length "2617";
#AL773603.1      sim4    exon    51279   51325   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "5"; transcript_start "2029"; transcript_end "2075"; transcript_length "2617";
#AL773603.1      sim4    exon    52262   52433   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "4"; transcript_start "2076"; transcript_end "2247"; transcript_length "2617";
#AL773603.1      sim4    exon    57232   57340   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "3"; transcript_start "2248"; transcript_end "2356"; transcript_length "2617";
#AL773603.1      sim4    exon    61464   61516   100     -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "2"; transcript_start "2357"; transcript_end "2409"; transcript_length "2617";
#AL773603.1      sim4    exon    69571   69759   97      -       .       gene_id "PTTG1IP"; transcript_id "Z50022.1"; exon_number "1"; transcript_start "2410"; transcript_end "2599"; transcript_length "2617"; match_strand "-"; exon_strand ".";

use Bio::EnsEMBL::Exon;
use Bio::EnsEMBL::DBSQL::DBAdaptor;

my %cds;
my %exons;
my %values;

my $host   = 'ecs1d';
my $user   = 'ensadmin';
my $pass   = 'ensembl';
my $port   = 19322;
my $dbname = 'otter_chr21';

my $db = new Bio::EnsEMBL::DBSQL::DBAdaptor(
  -host   => $host,
  -user   => $user,
  -pass   => $pass,
  -port   => $port,
  -dbname => $dbname
);

my $analysis = new Bio::EnsEMBL::Analysis(-logic_name => 'curated');

$db->assembly_type('RIKEN');
my $slice = $db->get_SliceAdaptor->fetch_by_chr_name('21');
#my $testslice = $db->get_SliceAdaptor->fetch_by_chr_start_end('21',16368550,16417237);



while (<>) {
  chomp;

  my @arr = split (' ', $_, 9);
  my $clone  = $arr[0];
  my $start  = $arr[3];
  my $end    = $arr[4];
  my $strand = $arr[6];

  my @arr2 = split (/\;/, $arr[8]);

  my %hashy;
  foreach my $str (@arr2) {
    my ($key, $val) = split (' ', $str, 2);

    # print "Found key $key $val\n";
    $key =~ s/ //g;
    $key =~ s/\"//g;
    $val =~ s/\"//g;
    if ($key ne "Description") {
      $val =~ s/^ +//;
      $val =~ s/ +$//;
      $key =~ s/\t//g;
      $val =~ s/\t//g;
    } else {
      $val =~ s/\t/ /g;
    }

    $hashy{$key} = $val;

    #print "Found key $key $val\n";

  }
  if ($arr[2] eq "exon") {
    my $id = $hashy{transcript_id};
    my $geneid = $hashy{gene_id};

    if (!defined($exons{$geneid}{$id})) {
      $exons{$geneid}{$id} = [];
    }
    my %exonhash;
    $exonhash{clone}  = $clone;
    $exonhash{start}  = $start;
    $exonhash{end}    = $end;
    $exonhash{strand} = $strand;
    $exonhash{values} = \%hashy;
    push (@{ $exons{$geneid}{$id} }, \%exonhash);

  } elsif ($arr[2] eq "CDS") {
    my $id = $hashy{transcript_id};
    my $geneid = $hashy{gene_id};

    if (!defined($cds{$geneid}{$id})) {
      $cds{$geneid}{$id} = [];
    }
    my %cdshash;
    $cdshash{clone}  = $clone;
    $cdshash{start}  = $start;
    $cdshash{end}    = $end;
    $cdshash{strand} = $strand;
    $cdshash{values} = \%hashy;
    push (@{ $cds{$geneid}{$id} }, \%cdshash);
  }
}

my @tilepath = @{$slice->get_tiling_path};
my %tilehash;

foreach my $tile (@tilepath) {
  $tilehash{$tile->component_Seq->clone->id} = $tile;
}

my %contigs;
foreach my $ref (\%cds, \%exons) {
  print "=============== GOT NEW REF ============\n";
  foreach my $gene (keys %$ref) {
    foreach my $tran (keys %{$ref->{$gene}}) {
      my $i;
      print STDERR "For gene $gene transcript " . $tran . " got " . scalar(@{$ref->{$gene}{$tran}}) . " exons\n";
      for ($i=0;$i<scalar(@{$ref->{$gene}{$tran}}); $i++) {
        my $ex = ${$ref->{$gene}{$tran}}[$i];

        if ($ex->{start} > $ex->{end}) {
          print STDERR "ERROR: Start > end in $gene $tran\n";
        }

        my $acc = $ex->{clone};
        $acc  =~ s/\..*$//;
  
        if ($tilehash{$acc} && 
            $ex->{end} >= $tilehash{$acc}->component_start &&
            $ex->{start} <= $tilehash{$acc}->component_end) {
  
          if ($ex->{start} < $tilehash{$acc}->component_start) {
            print "Clipping start\n";
            $ex->{start} = $tilehash{$acc}->component_start;
            $ex->{clipped_start} = 1;
          }
          if ($ex->{end} > $tilehash{$acc}->component_end) {
            print "Clipping end\n";
            $ex->{end} = $tilehash{$acc}->component_end;
            $ex->{clipped_end} = 1;
          }
          
          my $tmpFeat=new Bio::EnsEMBL::SimpleFeature(-start  => $ex->{start},
                                                      -end    => $ex->{end},
                                                      -strand => $ex->{strand},
                                                     );
          if (!defined($contigs{$acc})) {
            $contigs{$acc} = $db->get_CloneAdaptor->
                                fetch_by_accession($acc)->get_all_Contigs()->[0];
            print STDERR "Got contig for $acc\n";
          }
  
          $tmpFeat->contig($contigs{$acc});
  
          print STDERR "Clone " . $acc . " " . $tmpFeat->start . " to " . 
                       $tmpFeat->end . " strand " . $tmpFeat->strand . "\n";
          $tmpFeat->transform($slice);
          print STDERR "Chromosomal " . $tmpFeat->start . " to " . $tmpFeat->end.
                       " strand " . $tmpFeat->strand . "\n";

	  $ex->{start}  = $tmpFeat->start;
	  $ex->{end}    = $tmpFeat->end;
	  $ex->{strand} = $tmpFeat->strand;

        } elsif (!$tilehash{$acc}) {
          print STDERR "Didn't find tile for $acc\n"; 
          ${$ref->{$gene}{$tran}}[$i] = undef;
        } else {
          print STDERR "Ignoring exon off GP\n";
          ${$ref->{$gene}{$tran}}[$i] = undef;
        }
      }
# Now compact transcript
      my @newexons;
      for ($i=0;$i<scalar(@{$ref->{$gene}{$tran}}); $i++) {
        if (defined(${$ref->{$gene}{$tran}}[$i])) {
          push @newexons,${$ref->{$gene}{$tran}}[$i];
        }
      }
      if (!scalar(@newexons)) {
        print "ERROR No exons on GP for $tran\n";
      }
      $ref->{$gene}{$tran} = \@newexons;
    }
  }
}


print "Finished remap\n";

my $author = new Bio::Otter::Author(
  -name  => 'Todd',
  -email => 'todd@????'
);

# foreach my $gene (keys %cds) {
#  foreach my $tran (keys %{$cds{$gene}}) {
foreach my $geneid (keys %exons) {
  print STDERR "Gene id " . $geneid . "\n";

  my $gene = new Bio::Otter::AnnotatedGene;
  $gene->analysis($analysis);

  my $geneinfo = new Bio::Otter::GeneInfo;

  $gene->gene_info($geneinfo);
  $gene->type($values{'type'});

  $geneinfo->name(new Bio::Otter::GeneName(-name => $geneid));
  $geneinfo->author($author);

  #SMJS Added and then removed
  $gene->stable_id($geneid);
  $gene->version(1);
  $gene->created(time);
  $gene->modified(time);

  foreach my $tranid (keys %{ $exons{$geneid} }) {
    print STDERR "Tran id  $tranid\n";

#    my %values = %{ ${$geneid}{$geneid2}{values} };
#
#    foreach my $key (keys %values) {
#      print STDERR "Gene Key $key " . $values{$key} . "\n";
#    }


    my $ecount = 1;
    my $tran   = new Bio::Otter::AnnotatedTranscript;

    my $traninfo = new Bio::Otter::TranscriptInfo;

    #foreach my $evi (@evidence) {
    #  $traninfo->evidence($evi);
    #}

    $gene->add_Transcript($tran);

    $tran->transcript_info($traninfo);
    $traninfo->class(
      new Bio::Otter::TranscriptClass(-name => 'Known'));
    $traninfo->name($tranid);
    $traninfo->author($author);

    $tran->stable_id($tranid);
    $tran->version(1);
    $tran->created(time);
    $tran->modified(time);

    my @exons = @{ $exons{$geneid}{$tranid} };

    my %evidence;

    foreach my $exon (@exons) {
      my $newexon = new Bio::EnsEMBL::Exon(
        -start  => $exon->{start},
        -end    => $exon->{end},
        -strand => $exon->{strand},
      );
      print "Exon start " . $exon->{start} . " end " . $exon->{end} . 
            " strand " . $exon->{strand} . "\n";

      $tran->add_Exon($newexon);
      $newexon->stable_id($tran->stable_id . ".$ecount");
      $ecount++;
      $newexon->phase(-1);
      $newexon->end_phase(-1);
      $newexon->version(1);
      $newexon->created(time);
      $newexon->modified(time);
      $newexon->contig($slice);
      $newexon->adaptor($db->get_ExonAdaptor);

      foreach my $key (keys %{ $exon->{values} }) {
        print STDERR "Exon value key $key " . $exon->{values}{$key} . "\n";
      }
    }

    if (defined($cds{$geneid}{$tranid})) {

      my @cdsexons = @{ $cds{$geneid}{$tranid} };
      my $mincds = -1;
      my $maxcds = -1;
      foreach my $cdsex (@cdsexons) {
        if ($mincds == -1) {
          $mincds = $cdsex->{start};
        }
        if ($maxcds == -1) {
          $maxcds = $cdsex->{end};
        }
        if ($cdsex->{start} < $mincds) {
          $mincds = $cdsex->{start};
        }
        if ($cdsex->{end} > $maxcds) {
          $maxcds = $cdsex->{end};
        }
        print STDERR "exon "
          . $cdsex->{start} . " "
          . $cdsex->{end} . " "
          . $cdsex->{strand} . "\n";
      }
      print STDERR "Min / max " . $mincds . " " . $maxcds . "\n";

      my $translation = new Bio::EnsEMBL::Translation;
      $translation->stable_id($tran->stable_id);
      $translation->version(1);
      $tran->translation($translation);
      my @exons = @{ $tran->get_all_Exons };
      foreach my $ex (@exons) {

        if ($mincds >= $ex->start && $mincds <= $ex->end) {

          if ($ex->strand == 1) {
            $translation->start_Exon($ex);
            $translation->start($mincds - $ex->start + 1);
          } else {
            $translation->end_Exon($ex);
            $translation->end($ex->end - $mincds + 1);
          }
        }
        if ($maxcds >= $ex->start && $maxcds <= $ex->end) {

          if ($ex->strand == 1) {
            $translation->end_Exon($ex);
            $translation->end($maxcds - $ex->start + 1);
          } else {
            $translation->start_Exon($ex);
            $translation->start($ex->end - $maxcds + 1);
          }
        }
      }

      # Finally the phase
      if ($exons[0]->strand == 1) {
        @exons = sort { $a->start <=> $b->start } @exons;
      } else {
        @exons = sort { $b->start <=> $a->start } @exons;
      }

      my $found_start = 0;
      my $found_end   = 0;
      my $phase       = 0;

         # Otter expects all translations to start in phase 0 so
          # have to modify start to cater for incomplete codons
          # at start of translation
          my $frame = get_initial_frame($tran);
          if ($frame != 0) {
            $translation->start($translation->start + $frame);
          }



      foreach my $exon (@exons) {
        if ($found_start && !$found_end) {
          $exon->phase($phase);
          $exon->end_phase(($exon->length + $exon->phase) % 3);
          $phase = $exon->end_phase;
        }
        if ($translation->start_Exon == $exon) {
          $exon->phase($phase);

          # Is this right?

          $exon->end_phase(($exon->length + $exon->phase) % 3);

          $phase       = $exon->end_phase;
          $found_start = 1;
        }
        if ($translation->end_Exon == $exon) {
          $found_end = 1;
        }
      }
    }

  }
  eval {
    print $gene->toXMLString . "\n";

    $gene->transform;

    foreach my $t (@{ $gene->get_all_Transcripts }) {
      if (defined($t->translation)) {
        print "Transcript " . $t->stable_id  . " has a translation\n";
        $t->translation->version(1);
      }
    }
#    $db->get_GeneAdaptor->store($gene);

  };
  if ($@) {
    print "ERROR: Can't write gene [$@]\n";
  } else {
    print "Written gene " . $gene->stable_id . "\n";
  }
}

#Handling for incomplete translations (don't always start on a codon boundary)
sub get_initial_frame {
  my ($trans) = @_;

  $trans->sort;

  #Fudge end phase
  foreach my $exon (@{ $trans->get_all_Exons }) {
    $exon->end_phase(0);
  }

  print "Trying to find translating frame\n";
  my $cdna = new Bio::Seq(-seq => $trans->translateable_seq);

  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    if ($pepseq !~ /\*/) {
      print "Frame $frame does translate\n";

      #      return (3-$frame)%3;
      return $frame;
    }
  }
  print "Failed to translate transcript in any phase\n";
  foreach my $frame (0 .. 2) {
    my $pepseq = $cdna->translate(undef, undef, $frame)->seq;
    chop $pepseq;
    print "Pepseq frame $frame = " . $pepseq . "\n";
  }
  return 0;
}

