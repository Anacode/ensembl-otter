#!/usr/local/bin/perl -w

### fix_object_naming

use strict;
use Bio::Otter::Lace::Defaults;
use Hum::Submission 'prepare_cached_statement';

{
    my $dataset_name = undef;
    
    my $usage = sub { exec('perldoc', $0) };
    my $test_flag = 1;
    Bio::Otter::Lace::Defaults::do_getopt(
        'h|help!'   => $usage,
        'dataset=s' => \$dataset_name,
        'test!'     => \$test_flag,
        ) or $usage->();
    $usage->() unless $dataset_name;
    my $cl = Bio::Otter::Lace::Defaults::make_Client();
    my $ds = $cl->get_DataSet_by_name($dataset_name);
    my $dba = $ds->get_cached_DBAdaptor;
    my $gene_aptr = $dba->get_GeneAdaptor;
    my $gene_db_id = $gene_aptr->list_current_dbIDs;
    
    save_gene_numbers($dba);
    save_tsct_names($dba);
    
    foreach my $id (@$gene_db_id) {
        $dba->begin_work;
        eval{
            fix_names($dba, $gene_aptr, $id);
        };
        if ($@) {
            $dba->rollback;
            print STDERR "ERROR: $@";
        }
        elsif ($test_flag) {
            $dba->rollback;
        }
        else {
            $dba->commit;
        }
    }
}

sub is_sequence_name {
    my( $name ) = @_;

    my $sth = prepare_cached_statement(q{
        SELECT count(*)
        FROM sequence
        WHERE sequence_name = ?
        });
    $sth->execute($name);
    
    my ($count) = $sth->fetchrow;
    $sth->finish;
    return $count;
}

sub fix_names {
    my( $dba, $gene_aptr, $id ) = @_;

    my $gene = $gene_aptr->fetch_by_dbID($id);
    my $old_gene_name = $gene->gene_info->name->name;
    printf STDERR "\nGENE: $old_gene_name\n";
    my ($gene_class, $gene_name) = get_class_and_name($old_gene_name);
    my ($clone3prime, $all_clones) = three_prime_clone_name($gene);

    ### Lock clones here

    my $fix_names = 0;
    my $gene_number = undef;
    if ($gene_name =~ /^(?:[Ee][Mm]:)?([^\.]+)\.(\d+)$/) {
        my $clone_root = $1;
        $gene_number   = $2;
        if (is_sequence_name($clone_root)) {
          $fix_names = 1;
        }
    }
    # Chromosome 14 gene names
    elsif ($gene_name =~ /^K14_.+_\d+$/) {
        $fix_names = 1;
    }

    # grep the gene number from the transcript if it wasn't in the name
    $gene_number ||= transcript_gene_number($gene);
    
    my $gene_clone_root = undef;
    if (name_is_clone_based($gene_name, $all_clones)) {
        print STDERR "  GENE NAME OK\n";
        $gene_clone_root = $gene_name;
    }
    #else {
    #    ($gene_number, $gene_clone_root) = make_new_gene_name($gene_number, $gene_class . $clone3prime);
    #}

    ### Deal with C22, RI, and GD genes and transcripts.
    ### Fix gene classes here too?

    my $tsct_list = $gene->get_all_Transcripts;
    my $tsct_rename_map = [];
    foreach my $tsct (@$tsct_list) {
        my $old_tsct_name = $tsct->transcript_info->name;
        my ($class, $name) = get_class_and_name($old_tsct_name);
        #if ($class ne $gene_class) {
        #    print STDERR "  CLASS POLLUTION: gene=$gene_class tsct=$class\n";
        #}
        print STDERR "  TSCT: $old_tsct_name\n";
        my ($gene_name_root, $variant_number) = $name =~ /^(.+)-(\d{3})$/;
        unless ($variant_number) {
            if (index($name, $gene_name) == 0 and $name =~ /(\d+)$/) {
                $variant_number = sprintf "%03d", $1;
            }
        }
        $gene_name_root ||= '';
        $variant_number ||= '001';

        # Exception if already has intl gene name
        next if $name eq $old_tsct_name and name_is_clone_based($name, $all_clones);
        
        # Rename transcript:
        unless ($gene_clone_root) {
            ($gene_number, $gene_clone_root) = make_new_gene_name($gene_number, $gene_class . $clone3prime);
        }
        
        my $new_tsct_name = "$gene_clone_root-$variant_number";
        while (transcript_name_exists($new_tsct_name)) {
            $variant_number++;
            $new_tsct_name = "$gene_clone_root-$variant_number";
            print STDERR "    INCREMENT TSCT: $variant_number\n";
        }
        save_transcript_name($new_tsct_name);
        print STDERR "    TSCT RENAME: $new_tsct_name\n";
        push(@tsct_rename_map, [$old_tsct_name, $new_tsct_name]);
        rename_transcript($dba, $tsct, $old_tsct_name, $new_tsct_name);
    }

    fix_transcript_remarks($dba, $tsct_list, $tsct_rename_map);

    if ($fix_names and $gene_name ne $gene_clone_root) {
        unless ($gene_clone_root) {
            print STDERR "  NO NEW GENE NAME\n";
            ($gene_number, $gene_clone_root) = make_new_gene_name($gene_number, $gene_class . $clone3prime);
        }
        print STDERR "  GENE RENAME: $gene_clone_root\n";
        rename_gene($dba, $gene, $old_gene_name, $gene_clone_root, $tsct_rename_map);
    }
    elsif ("$gene_class$gene_name" ne $old_gene_name) {
        print STDERR "  GENE CLASS RENAME: $gene_class$gene_name\n";
        rename_gene($dba, $gene, $old_gene_name, "$gene_class$gene_name", $tsct_rename_map);
    }

    # Need to fix transcript and gene remarks.
}

sub rename_transcript {
    my( $dba, $tsct, $old, $new ) = @_;
    
    my $info_id = $tsct->transcript_info->dbID
        or die "No dbID for transcript";
    my $ren = $dba->prepare(q{
        UPDATE transcript_info
        SET name = ?
        WHERE transcript_info_id = ?
        });
    $ren->execute($new, $info_id);

    my $arch = $dba->prepare(q{
        REPLACE transcript_synonym( transcript_name
              , transcript_synonym)
        VALUES (?,?)
        });
    $ren->execute($new, $old);
}

sub rename_gene {
    my( $dba, $gene, $old, $new, $tsct_rename_map ) = @_;
    
    my $g_info_id = $gene->gene_info->dbID
        or die "No dbID for gene";
    my $ren = $dba->prepare(q{
        UPDATE gene_name
        SET name = ?
        where gene_info_id = ?
        });
    $ren->execute($new, $g_info_id);
    
    my $arch = $dba->prepare(q{
        INSERT gene_synonym( name
              , gene_info_id )
        VALUES (?,?)
        });
    $ren->exectue($old, $g_info_id);
    
    ### fix gene_remarks
}

sub fix_transcript_remarks {
    my( $dba, $tsct_list, $tsct_rename_map) = @_;
    
    ### implement
}

sub name_is_clone_based {
    my( $name, $clone_names ) = @_;
    
    foreach my $clone (@$clone_names) {
        return 1 if index($name, $clone) == 0;
        #print STDERR "  NO MATCH: $clone\n";
    }
    return 0;
}

sub get_class_and_name {
    my( $name ) = @_;
    
    my $class = '';
    if ($name =~ s/^(GD|RI|C22)://) {
        $class = $1;
    }
    elsif ($name =~ s/\.(GD|RI|C22)\b//) {
        $class = $1;
    }
    $class = '' if $class eq 'C22';
    $class .= ':' if $class;
    return( $class, $name );
}

sub transcript_gene_number {
    my( $gene ) = @_;
    
    my $tsct_list = $gene->get_all_Transcripts;

    my( %gene_n );
    foreach my $name (map $_->transcript_info->name, @$tsct_list) {
        if ($name =~ /(\d+)-\d{3}$/) {
            $gene_n{$1}++;
        }
    }
    my ($most_common) = sort {$gene_n{$b} <=> $gene_n{$a}} keys %gene_n;
    return $most_common;
}

sub three_prime_clone_name {
    my( $gene ) = @_;
    
    my $tsct_list = $gene->get_all_Transcripts;
    
    my $longest = [];
    my( %all_clone_names );
    foreach my $tsct (@$tsct_list) {
        my $clone_list = [map $_->contig->clone->id, @{$tsct->get_all_Exons}];
        for (my $i = 1; $i < @$clone_list;) {
            if ($clone_list->[$i] eq $clone_list->[$i-1]) {
                splice(@$clone_list, $i, 1);
            } else {
                $i++;
            }
        }
        #print STDERR "   @$clone_list\n";
        foreach my $clone_name (@$clone_list) {
            $clone_name =~ s/\.\d+$//;  # Trim SV from ACC.SV names
            $all_clone_names{$clone_name} = 1;
        }
        $longest = $clone_list if @$clone_list > @$longest;
    }
    #print STDERR " + @$longest\n";
    die "No clone list!" unless @$longest;
    my $clone3prime = pop @$longest;
    $clone3prime =~ s/\.\d+$//; # Trim SV from ACC.SV names
    #print STDERR "   end = $clone3prime\n";
    return($clone3prime, [keys %all_clone_names]);
}

sub make_new_gene_name {
    my( $gene_number, $clone3prime ) = @_;
    
    $gene_number ||= new_gene_number($clone3prime);
    my $new_gene_name = "$clone3prime.$gene_number";
    while (gene_exists($new_gene_name)) {
        $gene_number++;
        $new_gene_name = "$clone3prime.$gene_number";
        print STDERR "  INCREMENT GENE: $gene_number ($new_gene_name)\n";
    }
    save_gene_name($new_gene_name);
    
    return($gene_number, $new_gene_name);
}


{
    my( %gene_max, %gene_name );

    sub save_gene_numbers {
        my( $dba ) = @_;
        
        foreach my $table (qw{ gene_name gene_synonym }) {
            my $sth = $dba->prepare(qq{ SELECT DISTINCT name FROM $table });
            $sth->execute;
            while (my ($name) = $sth->fetchrow) {
                $gene_name{$name}++;
                if (my ($root, $n) = $name =~ /(.+)\.(\d+)/) {
                    if (my $max = $gene_max{$root}) {
                        $gene_max{$root} = $n if $n > $max;
                    } else {
                        $gene_max{$root} = $n;
                    }
                }
            }
        }
    }
    
    sub gene_exists {
        my( $name ) = @_;
        
        return $gene_name{$name};
    }
    
    sub save_gene_name {
        my( $name ) = @_;
        
        $gene_name{$name}++;
    }
    
    sub new_gene_number {
        my( $root ) = @_;
        
        my( $n );
        if ($n = $gene_max{$root}) {
            $n++;
        } else {
            $n = 1;
        }
        $gene_max{$root} = $n;
        return $n;
    }
}

{
    my( %tsct_name );
    
    sub save_tsct_names {
        my( $dba ) = @_;
        
        my $sth = $dba->prepare(q{ SELECT distinct name FROM transcript_info });
        $sth->execute;
        while (my ($name) = $sth->fetchrow) {
            $tsct_name{$name}++;
        }
    }
    
    sub save_transcript_name {
        my( $name ) = @_;
        
        $tsct_name{$name}++;
    }
    
    sub transcript_name_exists {
        my( $name ) = @_;
        
        return $tsct_name{$name};
    }
}

__END__

=head1 NAME - fix_object_naming

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

