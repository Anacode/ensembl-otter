#!/usr/local/bin/perl -w

### fetch_assembly_tags

use strict;
use Hum::Submission 'prepare_statement';
use Hum::AnaStatus::Sequence;

use Bio::EnsEMBL::Slice;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotatedClone;

use Getopt::Long 'GetOptions';

$| = 1;

my ($dataset, $verbose, @sets, @clones, $clone_list);

my $help = sub { exec('perldoc', $0) };


Bio::Otter::Lace::Defaults::do_getopt('ds|dataset=s' => \$dataset,
				      'v|verbose'    => \$verbose,
				      's|set=s@'     => \@sets,
				      'c|clone=s@'   => \@clones,
				      'clist=s'      => \$clone_list,
				      'h|help'       => $help,
				     ) or $help->(); # plus default options

$help->() unless ($dataset && (@sets || @clones || $clone_list));

{
  my $client       = Bio::Otter::Lace::Defaults::make_Client();
  my $dset         = $client->get_DataSet_by_name($dataset);
  my $otter_db     = $dset->get_cached_DBAdaptor;
  my $atagged_ctgs = get_assembly_tagged_clones($otter_db);

  # options to populate assembly_tag table, see also POD

  if ( @sets ) {
    my @tmp;
    if ( $sets[0] eq "all" ){
      warn "Fetching all assembly types";
      my $sql = q{SELECT assembly_type FROM sequence_set};
      my $sth = $otter_db->prepare($sql);
      $sth->execute;
      while ( my ($type) = $sth->fetchrow_array()) {
	push (@tmp, $type);
      }
      $sth->finish;
      @sets = @tmp;
    }

    my $type;
    foreach $type ( @sets ) {

      print "Working on $type\n\n";
      warn "\tWorking on $type\n";

      $otter_db->assembly_type($type); # replace the default sequence set setting
      my $seqSet = $dset->get_SequenceSet_by_name($type);
      my $clones = $dset->fetch_all_CloneSequences_for_SequenceSet($seqSet);

      fetch_by_clone_obj($clones, $otter_db, $atagged_ctgs, $type);
    }
  }

  elsif ( @clones ) {
    fetch_by_clone_name(\@clones, $otter_db, $atagged_ctgs);
  }

  elsif ( $clone_list ){
    my $clones = [];
    open(my $fh, $clone_list) || die $!;
    while (<$fh>){
      chomp;
      push(@$clones, $_) if $_; # ignore empty lines
    }

    fetch_by_clone_name($clones, $otter_db, $atagged_ctgs);
  }
}

sub fetch_by_clone_name {

  my ($clones, $otter_db, $atagged_ctgs) = @_;
  my $cloneAd = $otter_db->get_CloneAdaptor;
  my $cl_obj = [];

  foreach ( @$clones ){
    push( @$cl_obj, $cloneAd->fetch_by_accession_version( split(/\./, $_)) );
  }

  fetch_by_clone_obj($cl_obj, $otter_db, $atagged_ctgs);
}

sub fetch_by_clone_obj {

  my ($clones, $otter_db, $atagged_ctgs, $fetched) = @_;

  my $cloneAd = $otter_db->get_CloneAdaptor;
  my %atagged_ctgs = %$atagged_ctgs;
  my (%seq_acefile_clone, $ctg_name, $ctg_strand, $ctg_id, $seq_name, $version, $acc, $to_do);

  foreach my $obj (@$clones) {

    $to_do = 0;
    # does only clones not yet assembly_tag tagged
    if ( ref($obj) eq "Bio::Otter::AnnotatedClone" && !exists $atagged_ctgs{$obj->get_all_Contigs->[0]->dbID} ){

      $to_do = 1;

      $acc        = $obj->embl_id;
      $ctg_name   = $obj->get_all_Contigs->[0]->name;
      $seq_name   = sanger_name($obj->embl_id);
      $ctg_id     = $obj->get_all_Contigs->[0]->dbID;
      $version    = $obj->embl_version;
      $ctg_strand = get_contig_strand($ctg_id, $otter_db);
    }

    elsif ( ref($obj) eq "Bio::Otter::Lace::CloneSequence" && !exists $atagged_ctgs{$obj->contig_id} ){

      $to_do = 1;

      $acc        = $obj->accession;
      $ctg_strand = $obj->contig_strand;
      $ctg_name   = $obj->contig_name;
      $seq_name   = sanger_name($obj->accession);
      $ctg_id     = $obj->contig_id;
      $version    = $obj->sv;
    }

    # skip clones in otter db where there is no corresponding accession in the submissions database
    eval {
      #Hum::AnaStatus::Sequence->new_from_seqname_sv($seq_name, $version);
      Hum::AnaStatus::Sequence->new_from_accession($acc);
    };

    # work out path to acefile with assembly_tags info of a Sanger clone
    if ( $@ && $verbose && $acc ){
      my ($sanger_id, $ver) = check_latest_embl_version_sanger_id( $acc, $otter_db );

      if ( $ctg_name && $obj->sv != $ver ){
        print "SKIP: $ctg_name is of SV ".$obj->sv.", current SV is $ver\n";
      }
      if ( $seq_name && lc($seq_name) ne lc($sanger_id) ){
	print "SKIP: $ctg_name has internal name ($seq_name) swapped with project_name $sanger_id\n";
      }
    }

    if ( !$@ && $to_do == 1 ){
      #my $seq = Hum::AnaStatus::Sequence->new_from_seqname_sv($seq_name, $version);
       my $seq = Hum::AnaStatus::Sequence->new_from_accession($acc);
      my $dir = $seq->analysis_directory;

      # double check existence of acefile
      if ( -e "$dir/rawdata/$seq_name.humace.ace" ) {
	my $humace_file = "$dir/rawdata/$seq_name.humace.ace";
	push(@{$seq_acefile_clone{$ctg_name}}, $humace_file, $ctg_strand, $ctg_id);
      }
      else {
	print "ERROR: $ctg_name ($seq_name) has no associated acefile at $dir/rawdata/\n";
      }
    }
  }
  undef $@;

  $fetched = "Clone fetch" unless $fetched;

  # parsing acefile for all Sanger clones of an assembly type in one go
  parse_ace(\%seq_acefile_clone, $otter_db, $fetched);
}

sub check_latest_embl_version_sanger_id {

  my ($acc, $otter_db) = @_;
  my ($sql, $sth);

  $sql = "SELECT   cl.embl_version "
       . "FROM     clone cl, contig ct "
       . "WHERE    ct.clone_id = cl.clone_id "
       . "AND      ct.name like '$acc%'"
       . "ORDER BY cl.embl_version DESC "
       . "LIMIT 1";

  $sth = $otter_db->prepare($sql);
  $sth->execute;

  my $version;
  while ( my $ver = $sth->fetchrow_array ) {
    $version = $ver;
  }
  $sth->finish;

  $sql = "SELECT pa.sanger_id, s.sequence_name "
       . "FROM   sequence s, project_acc pa, project_dump pd "
       . "WHERE  pa.accession = ? "
       . "AND    pa.sanger_id = pd.sanger_id "
       . "AND    pd.seq_id = s.seq_id "
       . "ORDER by s.sequence_version DESC LIMIT 1";

  $sth = prepare_statement($sql);
  $sth->execute($acc);

  while ( my ($sanger_id, $seq_name) = $sth->fetchrow_array ) {
    $sanger_id =~ s/^_//;
    $sanger_id = lcfirst($sanger_id);
    return $sanger_id, $version;
  }
  $sth->finish;
}

sub get_assembly_tagged_clones {

  my $otter_db = shift;

  my $done_cln_ids = [];
  my %ctg_ids;

  my $sql = "SELECT clone_id FROM assembly_tagged_clone WHERE transferred = ?";
  my $sth = $otter_db->prepare($sql);
  $sth->execute("yes");
  while ( my $id = $sth->fetchrow_array ) {
    push(@$done_cln_ids, $id);
  }
  $sth->finish;

  foreach my $cln_id ( @$done_cln_ids ){
    my $sql = "SELECT ctg.contig_id FROM contig ctg, clone cl WHERE cl.clone_id = ? AND ctg.clone_id = cl.clone_id";
    my $sth = $otter_db->prepare($sql);
    $sth->execute($cln_id);

    while ( my $ctg_id = $sth->fetchrow_array ) {
      $ctg_ids{$ctg_id} = $cln_id unless $ctg_ids{$ctg_id};
    }
  }

  $sth->finish;
  return \%ctg_ids;
}

sub get_contig_strand {

  my ($ctg_id, $otter_db) = @_;
  my $sql = "SELECT e.contig_strand FROM exon e, contig c WHERE c.contig_id = ? AND c.contig_id = e.contig_id";
  my $sth = $otter_db->prepare($sql);
  $sth->execute($ctg_id);

  while ( my $strand = $sth->fetchrow_array ) {
    return $strand;
  }
  $sth->finish;
}

sub parse_ace {

  my ($href, $otter_db, $fetched)  = @_;

  my %seq_acefile_clone = %$href;
  my $asmblyTagAd = $otter_db->get_AssemblyTagAdaptor;

  my ($fh, $line);
  my $counter = 0;
  my %contig_tag_data;

  # go thru each contig of an assembly type
  foreach my $ctg_name ( keys %seq_acefile_clone ){

    my @values;
    open( $fh, $seq_acefile_clone{$ctg_name}->[0] ) || die "Failed to read ".$seq_acefile_clone{$ctg_name}->[0];

    print "\n", $ctg_name, " => ",  $seq_acefile_clone{$ctg_name}->[0], "\n" if $verbose;

    my $ctg_id     = $seq_acefile_clone{$ctg_name}->[2];

    while ( $line = <$fh> ){

      my $ctg_strand = $seq_acefile_clone{$ctg_name}->[1];
      my ( $tag_type, $tag_start, $tag_end, $tag_info);

      if ( $line =~ /^Assembly_[Tt]ags\s+\"(-)\"\s+(\d+)\s+(\d+)\s+\"(.+)\"/ ||
	   $line =~ /^Assembly_[Tt]ags\s+(Oligo|unsure)\s+(\d+)\s+(\d+)\s+\"(.+)\"/i){

	$counter++;

	($1 eq "-") ? ($tag_type = "Misc") : ($tag_type = $1);

	# convertion for Ensembl/otter_db: starting coord is always smaller, so flip if not so
        #                                  starting coord > end coord means minus strand

	if ( $2 > $3 ){
	  $tag_start = $3;
	  $tag_end   = $2;
	  if ( $ctg_strand == -1 ){
	    $ctg_strand = 1;
	  }
	  else {
	    $ctg_strand = -1;
	  }
	}
	elsif ( $2 < $3 ) {
	  $tag_start  = $2;
	  $tag_end    = $3;
	}
	elsif ( $2 == $3 ){
	  $tag_start = $tag_end = $2;
	  $ctg_strand = 1;
	}

	$4 ? ($tag_info = $4) : ($tag_info = "Null");
   	$tag_info = trim($tag_info);

	if ( $verbose ){
	  print "flip\n" if $2>$3;
	  print "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n";
	}
	push(@{$contig_tag_data{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info);
      }
      if ( $line =~ /^(Clone_\w+_end)\s+(.+)\s+(\d+)/i ){

	$counter++;

	$tag_type  = $1;
	$tag_start = $3;
	$tag_end   = $3;  # set end value to start value where no end value present
	$tag_info  = $2;
	$tag_info =~ s/\"//g;
	$tag_info = trim($tag_info);
	$ctg_strand = 1;
	
	print "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n" if $verbose;
	push(@{$contig_tag_data{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info);
      }
    }
  }

  if ( $counter != 0 ){

    # commit/rollback for each assembly type / clones / clone_list
    $otter_db->begin_work;
    store(\%contig_tag_data, $otter_db);

    unless ( $@ ){
      printf("> %-35s successful: $counter\n\n", $fetched);
      $otter_db->commit;
    }
    else {
      print $@;
      printf("> %-35s failed\n\n", $fetched);
      $otter_db->rollback;
    }
  }
  else {
    $otter_db->begin_work;
    printf("> %-35s no info or clone already is assembly_tag tagged\n\n", $fetched);
    $otter_db->commit;
  }
  undef $@;
}

sub trim {
  my $st = shift;
  $st =~ s/\\n/ /g;
  $st =~ s/\s{1,}/ /g;
  return $st;
}

sub sanger_name {
  my( $acc ) = @_;

  my $sth = prepare_statement(qq{
        SELECT s.sequence_name
        FROM project_acc a
          , project_dump d
          , sequence s
        WHERE a.sanger_id = d.sanger_id
          AND d.seq_id = s.seq_id
          AND a.accession = '$acc'
        ORDER BY s.seq_id DESC
        LIMIT 1
        });

  $sth->execute;
  my $sanger_name = $sth->fetchrow;
  $sth->finish;

  return $sanger_name if $sanger_name;
}

sub store {

  my ($ctg_tag_data, $otter_db) = @_;

  my %ctg_tag_data = %$ctg_tag_data;

  eval {
    foreach my $ctg_name ( keys %ctg_tag_data ) {

      my @values = @{$ctg_tag_data{$ctg_name}};

      for ( my $i = 0; $i < scalar @values; $i=$i+6 ) {

	# column contig_end/tag_info can be null for tag_type = clone_left_end or clone_right_end
	$values[$i+5] = '' if  $values[$i+5] eq "Null";

	my $sql = "INSERT IGNORE INTO assembly_tag (tag_id, contig_id, contig_start, contig_end, contig_strand, tag_type, tag_info) "
	        . "VALUES (?,?,?,?,?,?,?)";

	my @vals = ('', @values[$i..$i+5]);

	my $sth = $otter_db->prepare($sql);
	$sth->execute(@vals);
	$sth->finish;

	# update also assembly_tagged_clone table, which is initially populated with all clones having transferred col = "no"
	my $sql_1 = "SELECT ct.clone_id FROM contig ct, clone cl WHERE ct.clone_id = cl.clone_id AND ct.contig_id = ?";
	$sth = $otter_db->prepare($sql_1);
	$sth->execute($values[$i]);
	
	my $sth1;
	while ( my $cln_id = $sth->fetchrow_array ){
	  my $sql_2 = "UPDATE assembly_tagged_clone SET transferred = ? WHERE clone_id = ?";
	  $sth1 = $otter_db->prepare($sql_2);
	  $sth1->execute("yes",$cln_id);
	}
	$sth1->finish;
      }
    }
  };
}


__END__


=head1 NAME - fetch_assembly_tags

=head1 SYNOPSIS

Script parameters: database_name (eg, fetch_assembly_tags B<-dataset> human B<-verbose> [optional]) followed by one of the 4 options, eg:

1. B<-set> chr4 B<-set> -chr20  (fetch all clones from one or more chromosomes)

2. B<-set> all (fetch all clones from all chromosomes)

3. B<-clone> AC000094.x B<-clone> AC000095.x  (fetch single or multiple clones [accession.version])

4. B<-clist> filename (fetch from list of clones as [accession.version] from file, one clone per line)

Verbose mode prints detailed info of assembly_tags.

=head1 DESCRIPTION

There are assembly_tags info for Sanger clones submitted to EMBL. This is stored in "submissions" database (B<~jgrg/bin/sql>)
and can be found in acefiles, eg, /nfs/disk100/humpub/analysis/projects/Chr_20/yR31BE7/20001221/rawdata/yR31BE7.humace.ace.

The Assembly_tags info is shown in AceDB under the Assembly_tags tag of a Sequence object and is stored in otterlace in B<assembly_tag> table

This script populates and updates the otter B<assembly_tag> and B<assemlby_tagged_clone> tables, respectively.
The latter table is populated by "INSERT INTO assembly_tagged_clone (clone_id) SELECT clone_id FROM clone;"
before hand, where all clones have the transferred column with value initially set to "no".
For clones which have assembly_tag data, it will be updated to "yes".

The B<assembly_tagged_clone> table allows quick look up of clones that have assembly_tag info.

Assembly_tag info in the otter DB is dumped out in EMBL format via the script B<emblDump> in the humscripts directory.
(To check out: cvs -d /nfs/humace2/CVS_master checkout humscripts)

=head1 AUTHOR

Chao-Kung Chen B<email> ck1@sanger.ac.uk

