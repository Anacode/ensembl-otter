#!/usr/local/bin/perl -w

### fetch_assembly_tags


use strict;
use Hum::Submission 'prepare_statement';
use Hum::AnaStatus::Sequence;

use Bio::EnsEMBL::Slice;

use Bio::Otter::Lace::Defaults;
use Bio::Otter::AnnotatedClone;

use Getopt::Long 'GetOptions';

$| = 1;

{
  my ($dataset, $verbose, @sets, @clones, $clone_list );

  my $help = sub { exec('perldoc', $0) };


  Bio::Otter::Lace::Defaults::do_getopt('ds|dataset=s' => \$dataset,
					'v|verbose'    => \$verbose,
					's|set=s@'     => \@sets,
					'c|clone=s@'   => \@clones,
					'clist=s'      => \$clone_list,
					'h|help'       => $help,
				       ) or $help->(); # plus default options

  $help->() unless ($dataset && (@sets || @clones || $clone_list));

  my $client   = Bio::Otter::Lace::Defaults::make_Client();
  my $dset     = $client->get_DataSet_by_name($dataset);
  my $otter_db = $dset->get_cached_DBAdaptor;

  #$otter_db->begin_work;

  # options to populate assembly_tag table, see also POD

  if ( @sets ) {

    my @tmp;
    if ( $sets[0] eq "all" ){
      warn "Fetching all assembly types";
      my $sql = q{SELECT assembly_type FROM sequence_set};
      my $sth = $otter_db->prepare($sql);
      $sth->execute;
      while ( my ($type) = $sth->fetchrow_array()) {
	push (@tmp, $type);
      }
      $sth->finish;
      @sets = @tmp;
    }

    my $type;
    foreach $type ( @sets ) {

      print "Working on $type\n\n";
      warn "\tWorking on $type";

      $otter_db->assembly_type($type); # replace the default sequence set setting
      my $seqSet = $dset->get_SequenceSet_by_name($type);
      my $clones = $dset->fetch_all_CloneSequences_for_SequenceSet($seqSet);

      fetch_by_clone_obj($clones, $otter_db, $type);
    }
  }

  elsif ( @clones ) {

    fetch_by_clone_name(\@clones, $otter_db);
  }

  elsif ( $clone_list ){

    my $clones = [];
    open(my $fh, $clone_list) || die $!;
    while (<$fh>){
      chomp;
      push(@$clones, $_) if $_; # ignore empty lines
    }

    fetch_by_clone_name($clones, $otter_db);
  }
}

sub fetch_by_clone_name {

  my ($clones, $otter_db) = @_;
  my $cloneAd = $otter_db->get_CloneAdaptor;
  my $cl_obj = [];

  foreach ( @$clones ){
    push( @$cl_obj, $cloneAd->fetch_by_accession_version(split(/\./, $_)) );
  }

  fetch_by_clone_obj($cl_obj, $otter_db);
}

sub fetch_by_clone_obj {

  my ($clones, $otter_db, $fetched) = @_;

  my $cloneAd = $otter_db->get_CloneAdaptor;
  my %seq_acefile_clone;
  my ($clone, $ctg_name, $ctg_strand, $ctg_id, $seq_name, $version);

  foreach my $obj (@$clones) {

    if ( ref($obj) eq "Bio::Otter::AnnotatedClone" ){

      $clone = $obj;
      $ctg_name   = $obj->get_all_Contigs->[0]->name;
      $ctg_id     = $obj->get_all_Contigs->[0]->dbID;
      $seq_name   = sanger_name($obj->embl_id);
      $version    = $obj->embl_version;
      $ctg_strand = get_contig_strand($ctg_id, $otter_db);
    }
    elsif ( ref($obj) eq "Bio::Otter::Lace::CloneSequence" ){

      # get Bio::Otter::AnnotatedClone obj via Bio::Otter::Lace::CloneSequence obj
      $clone = $cloneAd->fetch_by_accession_version($obj->accession, $obj->sv);

      $ctg_strand = $obj->contig_strand;
      $ctg_name   = $obj->contig_name;
      $ctg_id     = $obj->contig_id;
      $seq_name   = sanger_name($obj->accession);
      $version    = $obj->sv;
    }

    # skip clones in otter db where there is no corresponding accession in the submissions database
    eval {
      Hum::AnaStatus::Sequence->new_from_seqname_sv($seq_name, $version);
    };

    # work out path to acefile with assembly_tags info of a Sanger clone
    unless ( $@ ){
      my $seq = Hum::AnaStatus::Sequence->new_from_seqname_sv($seq_name, $version);
      my $dir = $seq->analysis_directory;

      # double check existence of acefile
      if ( -e "$dir/rawdata/$seq_name.humace.ace" ) {
	my $humace_file = "$dir/rawdata/$seq_name.humace.ace";
	push(@{$seq_acefile_clone{$ctg_name}}, $humace_file, $clone, $ctg_strand, $ctg_id);
      }
    }
  }
  undef $@;

  $fetched = "Clone fetch" unless $fetched;

  # parsing acefile for all Sanger clones of an assembly type in one go
  parse_ace(\%seq_acefile_clone, $otter_db, $clones, $fetched);
}

sub get_contig_strand {

  my ($ctg_id, $otter_db) = @_;
  my $sql = "SELECT e.contig_strand FROM exon e, contig c WHERE c.contig_id = ? AND c.contig_id = e.contig_id";
  my $sth = $otter_db->prepare($sql);
  $sth->execute($ctg_id);

  while ( my $strand = $sth->fetchrow_array ) {
    return $strand;
    $sth->finish;
  }
}

sub parse_ace {
  my ($href, $otter_db, $clones, $fetched)  = @_;

  my %seq_acefile_clone = %$href;
  my $asmblyTagAd = $otter_db->get_AssemblyTagAdaptor;

  my ($fh, $line);
  my $counter = 0;
  my %contig_tag_data;

  # go thru each contig of an assembly type
  foreach my $ctg_name ( keys %seq_acefile_clone ){

    my @values;
    open( $fh, $seq_acefile_clone{$ctg_name}->[0] ) || die "Failed to read ".$seq_acefile_clone{$ctg_name}->[0];

    print "\n", $ctg_name, " => ",  $seq_acefile_clone{$ctg_name}->[0], "\n";

    my $clone      = $seq_acefile_clone{$ctg_name}->[1];
    my $ctg_id     = $seq_acefile_clone{$ctg_name}->[3];

    while ( $line = <$fh> ){

      my $ctg_strand = $seq_acefile_clone{$ctg_name}->[2];
      my ( $tag_type, $tag_start, $tag_end, $tag_info);

      if ( $line =~ /^Assembly_[Tt]ags\s+\"(-)\"\s+(\d+)\s+(\d+)\s+\"(.+)\"/ ||
	   $line =~ /^Assembly_[Tt]ags\s+(Oligo|unsure)\s+(\d+)\s+(\d+)\s+\"(.+)\"/i){

	$counter++;

	($1 eq "-") ? ($tag_type = "Misc") : ($tag_type = $1);

	# convertion for Ensembl/otter_db: starting coord is always smaller, so flip if not so
        #                                  starting coord > end coord means minus strand

	if ( $2 > $3 ){
	  $tag_start = $3;
	  $tag_end   = $2;
	  if ( $ctg_strand == -1 ){
	    $ctg_strand = 1;
	  }
	  else {
	    $ctg_strand = -1;
	  }
	}
	elsif ( $2 < $3 ) {
	  $tag_start  = $2;
	  $tag_end    = $3;
	}
	elsif ( $2 == $3 ){
	  $tag_start = $tag_end = $2;
	  $ctg_strand = 1;
	}

	$4 ? ($tag_info = $4) : ($tag_info = "Null");
   	$tag_info = trim($tag_info);

	print "flip\n" if $2>$3;
	print "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n";
	push(@{$contig_tag_data{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info, $clone);
      }
      if ( $line =~ /^(Clone_\w+_end)\s+(.+)\s+(\d+)/i ){

	$counter++;

	$tag_type  = $1;
	$tag_start = $3;
	$tag_end   = $3;  # set end value to start value where no end value present
	$tag_info  = $2;
	$tag_info =~ s/\"//g;
	$tag_info = trim($tag_info);
	$ctg_strand = 1;

	print "$ctg_id : $tag_type : $ctg_strand : $tag_start : $tag_end : $tag_info\n";
	push(@{$contig_tag_data{$ctg_name}}, $ctg_id, $tag_start, $tag_end, $ctg_strand, $tag_type, $tag_info, $clone);
      }
    }
  }

  if ( $counter != 0 ){

    # commit/rollback for each assembly type / clones / clone_list
    $otter_db->begin_work;
    store(\%contig_tag_data, $otter_db);

    unless ( $@ ){
      printf("> %-35s successful: $counter\n\n", $fetched);
      $otter_db->commit;
    }
    else {
      print $@;
      printf("> %-35s failed\n\n", $fetched);
      $otter_db->rollback;
    }
  }
  else {
    $otter_db->begin_work;
    printf("> %-35s no info\n\n", $fetched);
    $otter_db->commit;
  }
  undef $@;
}

sub trim {
  my $st = shift;
  $st =~ s/\\n/ /g;
  $st =~ s/\s{1,}/ /g;
  return $st;
}

sub sanger_name {
  my( $acc ) = @_;

  my $sth = prepare_statement(qq{
        SELECT s.sequence_name
        FROM project_acc a
          , project_dump d
          , sequence s
        WHERE a.sanger_id = d.sanger_id
          AND d.seq_id = s.seq_id
          AND a.accession = '$acc'
        ORDER BY s.seq_id DESC
        LIMIT 1
        });

  $sth->execute;
  my $sanger_name = $sth->fetchrow;

  return $sanger_name if $sanger_name;

}

sub store {

  my ($ctg_tag_data, $otter_db) = @_;

  my %ctg_tag_data = %$ctg_tag_data;

  eval {
    foreach my $ctg_name ( keys %ctg_tag_data ) {

      my @values = @{$ctg_tag_data{$ctg_name}};

      for ( my $i = 0; $i < scalar @values; $i=$i+7 ) {

	# column contig_end/tag_info can be null for tag_type = clone_left_end or clone_right_end
	$values[$i+5] = '' if  $values[$i+5] eq "Null";

	my $sql = "INSERT IGNORE INTO assembly_tag (tag_id, contig_id, contig_start, contig_end, contig_strand, tag_type, tag_info) "
	        . "VALUES (?,?,?,?,?,?,?)";

	my @vals = ('', @values[$i..$i+5]);

	my $sth = $values[-1]->adaptor->db->prepare($sql);
	$sth->execute(@vals);
	$sth->finish;

	# update also assembly_tagged_clone table, which is initially populated with all clones having transferred col. set to "no"
	my $sql_1 = "SELECT ct.clone_id FROM contig ct, clone cl WHERE ct.clone_id = cl.clone_id AND ct.contig_id = ?";
	my $sth_1 = $otter_db->prepare($sql_1);
	$sth_1->execute($values[$i]);
	
	while ( my $cln_id = $sth_1->fetchrow_array ){
	  my $sql_2 = "UPDATE assembly_tagged_clone SET transferred = ? WHERE clone_id = ?";
	  my $sth_2 = $otter_db->prepare($sql_2);
	  $sth_2->execute("yes",$cln_id);
	  $sth_2->finish;
	}
      }
    }
  };
}


__END__


=head1 NAME - fetch_assembly_tags

=head1 SYNOPSIS

Script parameters: database_name [-ds dataset] followed by one of the 4 options, eg:

1. B<-set> chr4 B<-set> -chr20  (fetch from one or more chromosomes)

2. B<-set> all (fetch from all chromosomes)

3. B<-clone> AC000094.x B<-clone> AC000095.x  (fetch single or multiple clones [accession.version])

4. B<-clist> filename (fetch from list of clones as [accession.version] from file, one clone per line)


=head1 DESCRIPTION

This script populates and updates the otter B<assembly_tag> and B<assemlby_tagged_clone> tables, respectively.
The latter table is populated by "INSERT INTO assembly_tagged_clone (clone_id) SELECT clone_id FROM clone"
before hand, where all clones have the transferred column with value initially set to "no".
For clones which have assembly_tag data, it will be updated to "yes".

The B<assembly_tagged_clone> table allows quick look up of clones that have assembly_tag info.

There are assembly_tags info for Sanger clones submitted to EMBL. This is stored in "submissions" database (B<~jgrg/bin/sql>)
and can be found in acefiles, eg, /nfs/disk100/humpub/analysis/projects/Chr_20/yR31BE7/20001221/rawdata/yR31BE7.humace.ace.

The Assembly_tags info is shown in AceDB under the Assembly_tags tag of a Sequence object and is stored in otterlace in B<assembly_tag> table


=head1 AUTHOR

Chao-Kung Chen B<email> ck1@sanger.ac.uk

