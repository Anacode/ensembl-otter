#!/usr/local/bin/perl -w

=head1 NAME

load_otter_ensembl

=head1 SYNOPSIS
 
  load_otter_ensembl (-pipe) 

=head1 DESCRIPTION

This script reads the assembly information from an agp file and pfetches the clone and contig details based on the accession. 
It then populates the assembly table in both databases ;
BEWARE! It is for gunshot sequencing projects like fugu, where one clone = one contig is the rule (and they are usually referred to as scaffolds. It does not deal with multiple contigs per clone.

example;
./Load_otter_ensembl -host ecs1d -user ensadmin -pass "ensembl" -dbname otter_test -name mySequenceSet -description 'test description' -chromosome chr12 clone_list

=head1 OPTIONS

    
    -host      host name for the otter database (gets put as host= in locator)
    -port      port number of the otter database
    -user      username for the otter database
    -pass      password for the otter databases   
    -dbname    what the name of otter database to connect is (dbname= in locator)
    
    -pipehost   host name for the pipeline database
    -pipeport   port for the pipeline databases 
    -pipeuser   username for the pipeline database 
    -pipepass   password fro the pipeline database 
    -pipedbname name of the pipeline database to connect to
    
    -name         name of the set of clones
    -description  description of thesequence set 
    -priority     analysis priority of the sequnce set
    -chromosome   name of the chromosome the set comes from 
       
       
    -module    Module name to load (Defaults to Bio::EnsEMBL::DBSQL::DBAdaptor)
    
    -help      displays this documentation with PERLDOC

    user should also supply either a list of accession numbers (one per line) or a .agp (golden path) file.
    

    NOTE: The first time this script is run, it expects arguments for the pipeline database (port, password, etc may be optional , depending on the way the database has been set up).
    These are then stored in  the otter database, so after that the user need only specify the otter database options and the set name and description.

=cut


use Benchmark;

use strict;
use Getopt::Long;
use Bio::SeqIO;
use Bio::EnsEMBL::Analysis;
use Bio::EnsEMBL::Clone;
use Bio::EnsEMBL::RawContig;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::SeqFetcher::Pfetch;
use Bio::EnsEMBL::Chromosome;

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Clone;

my $input_type; 
{
#    my $t0 = new Benchmark; # test the time taken for the script to run.
    
    # some important variables (and some less inportant ones that look neater up here) 
    my $sth ;                 # used as a variable for storing the various statement handles used through the script
    my $agp_file ;            # the file containing the assembly details
    my $pipe_analysis ;       # analysis adaptor for the pipeline db
    my $pipe_clone_adaptor ;  # clone adaptor for the pipeline db
    my $otter_analysis ;      # analysis adaptor for the otter deb
    my $otter_clone_adaptor;  # clone adaptor for the otter db
    my $chromosome_id ;
    my @sgp ;           #static golden path. stores an array of arrays. each sub array contains the details for 1 row in the asembly table effectivley
    my @sgp_pipe ;
    my @sgp_otter;
    my @alternative_id ;      # stores the id of contigs for one of the dbs
    my $sv;                   # sequence version
    my $module = 'Bio::EnsEMBL::DBSQL::DBAdaptor';
    my @file_values;          # stores the values given in each line of input as an array of the component parts
    my $chromosome_name;
    my $set_name;
    my $end_coord;            # stores the end coord of the last contig in sequence set - used when appending contigs to a previous set  
              
    
    
    ## next set of variables are overwritten if a command line option is specified
    my $host = 'localhost'; # holds the (default) value for the otter port
    my $port = 3306;        # holds the (default) value for the otter port 
    my $dbname = 'otter';   # holds the (default) value for the otter database name
    my $analysis_priority =  5; # hold the deafulat value for the analysis priority 
    my $description;    
    
    my(                                      $dbuser,     $dbpass ); ## stores the otter username and password
    my( $pipehost, $pipeport, $pipedbname, $pipedbuser, $pipedbpass );##stores the pipeline db and password
    ####---------------

    my $help = 0;
    &GetOptions(
            'host=s'        => \$host,
	    'port=i'        => \$port,
	    'user=s'        => \$dbuser,
	    'pass=s'        => \$dbpass,
            'dbname=s'      => \$dbname,

            'pipehost=s'    => \$pipehost,      
	    'pipeport=i'    => \$pipeport,      
	    'pipeuser=s'    => \$pipedbuser,    
	    'pipepass=s'    => \$pipedbpass,
            'pipedbname=s'  => \$pipedbname, 

	    'module=s'      => \$module,
       	    'h|help'        => \$help,
            'description=s' => \$description,
            'priority=i'    => \$analysis_priority ,
            'chromosome=s'  => \$chromosome_name, 
            'set|name=s'        => \$set_name,
            );
    
    my $otter_db = Bio::EnsEMBL::DBSQL::DBAdaptor->new (   
        -HOST   => $host,
        -PORT   => $port,
        -USER   => $dbuser,
        -PASS   => $dbpass,
        -DBNAME => $dbname,
        );
        
    
    my $pipe_options = get_pipeline_options($otter_db);
    if ($pipe_options) {
        # Check none of the pipe options are set on command line
        if ($pipehost or $pipeport or $pipedbname or $pipedbuser or $pipedbpass) {
            die "pipeline db options are specified on command line, but are already stored in the otter db";
        }
    } else {
        # Pipeline database defaults to same values as otter
        $pipehost   ||= $host  ;
        $pipeport   ||= $port  ;
        $pipedbname ||= $dbname;
        $pipedbuser ||= $dbuser;
        $pipedbpass ||= $dbpass;
        
        $pipe_options = {
            -HOST   => $pipehost,
            -PORT   => $pipeport,
            -USER   => $pipedbuser,
            -PASS   => $pipedbpass,
            -DBNAME => $pipedbname,
            };
            
        save_pipeline_options($otter_db, $pipe_options);
    }
    
  
    my $pipeline_db = Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor->new(%$pipe_options);

    if ($help){
        exec('perldoc', $0); #runs perldoc on itself (variable $0 stores the program name)
    } 
    
    if (! defined $description){
        die "no description given" ;
    }

    if (! defined  $set_name){
        die "you need to give the set name as an argument";
    }


    ## takes the last arguments as the filename to be read
    $agp_file = @ARGV->[0];
    if (! defined $agp_file ) {warn 'cannot load assembly details, as there is no agp file';}
    open AGP, "$agp_file" or die "couldnt open $agp_file";




    #------------------------- read input file -----------------------------------------    
    # first go through file , check that the file contains the same chromosome for each entry store values an an array

    my $line_counter = 0;
    my $prev_chr_name ='';
    while(<AGP>){
        print STDERR "reading line ". ($line_counter + 1) ."\n";
        $line_counter ++;    
    
        my @line_in_array = split /[\s]/ , $_ ; 
        # 0       1       2       3       4       5               6       7       8
        # chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +
        # splits each line into its component parts - puts line in a temporary array (splits the line on whitespace)
    
 
        if(@line_in_array == 9 ){
            # we must have the full file rather than just clone names
            $input_type = "AGP";
            my $chromosome_name = @line_in_array->[0]; 
            my $type = @line_in_array->[4];
            if ($prev_chr_name eq $chromosome_name){
                die "clones on different chromosomes" unless $chromosome_name eq $prev_chr_name ;
            }
            else{
                $prev_chr_name = $chromosome_name;
            }
        
            # if clones are not finished , dont add them to database
            if (! $type  eq 'F'){
                      next;            
            }
               
        }
        elsif(@line_in_array == 1){ 
            # cant think of anything to check  here yet
            # we will end up here if the input file has only a list of contigs in it. 
            $input_type = "LIST";
            if (! defined $chromosome_name){
                # we need a chromosome name if only a list of contigs is given
                die "you need to provide the name of a chromosome when the input file is a list of clones";
            }
            
        }
        else {
            print STDERR "\n\tinput file does not have the expected number of columns at line $line_counter\n\tshould have the format ...\n\tchr_20  2808333 2934911 29      F       AL121905.0      101     126679  +";
            print STDERR "line $line_counter has been skipped";
            next; 
        }
        ## store all values in this array, so that the file does not need to be re-read
        push (@file_values , [@line_in_array]);     
    }
    #--------------------------------finished reading input file ------------------------


    

    # die on INT signal    - should clean things up a bit , if program terminates early
    $SIG{INT} = sub {my $sig=shift;die "exited after SIG$sig";};


    # update the sequence sets table and return the coord of the last contig if available
    $end_coord = check_sequence_set($otter_db, $set_name);
    my $other_end_coord = check_sequence_set($pipeline_db , $set_name);
    if ($other_end_coord > $end_coord)  { $end_coord = $other_end_coord };
    
    
    # create an analysis adaptor and a clone adaptor for the otter database and then one of each for the pipeline db
    #$otter_analysis =      $otter_db->get_AnalysisAdaptor;
    $otter_clone_adaptor = $otter_db->get_CloneAdaptor;
    $pipe_analysis =      $pipeline_db->get_AnalysisAdaptor;
    $pipe_clone_adaptor = $pipeline_db->get_CloneAdaptor;
    
    ## default value for just now. - true value will be added by a different script
    my $superctg_ori = 1;  

    #### pfetch the details of a clone
    my  $pfetch = Bio::EnsEMBL::Pipeline::SeqFetcher::Pfetch->new();
    my $seq ; # stores the sequence (of each line entry) and name as a bio::seq object  
    
    # Get SubmitContig analysis object for priming the pipeline
    my $ana_obj = $pipe_analysis->fetch_by_logic_name('SubmitContig');
   
    unless ($ana_obj) {
         $ana_obj = new Bio::EnsEMBL::Pipeline::Analysis(
            -LOGIC_NAME     => 'SubmitContig',
            -INPUT_ID_TYPE  => 'CONTIG',
            );

         $pipe_analysis->store($ana_obj);
    }
    my $state_info = $pipeline_db->get_StateInfoContainer;
    



    ## while loop effectively reads each line of a  *.agp file (that has already been done and stored in @file values)
    ## it pfetches the sequence details based on the accsession number and version.
    my ($super_contig_name, $chr_start,$chr_end, $n, $type, $acc_ver, $ctg_start, $ctg_end,$ctg_ori,) ; 
    my $otter_chromosome  =  get_chromosome($otter_db    , $chromosome_name );
    my $pipe_chromosome   =  get_chromosome($pipeline_db , $chromosome_name );
   
    foreach my $file_line (@file_values) {       
        my @value_array ;            
        if ($input_type eq 'LIST'){
            ## all we have is the list of contigs/clones - need to give default values for agp
            $acc_ver = $file_line->[0];
            $seq = $pfetch->get_Seq_by_acc($acc_ver);
            $super_contig_name = $chromosome_name;  # should be available from the command line if we have a clone list as input (or we would have died earlier)       
            $n = 5;    # does this get used for anything? - don't think so
            $type = 'F' ;        
            $ctg_ori =  '+';
            $chr_start =  $end_coord + 10000 ;
            $chr_end = ($chr_start + $seq->length + 1);
            $ctg_start = 1 ;
            $ctg_end =  1 + $seq->length;
            $end_coord = $chr_end; # so that it is in a suitable position for next time              
        
        }
        else {
        # input file must be in AGP format
        # 0       1       2       3       4       5               6       7       8
        # chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +
            (
            $super_contig_name,
            $chr_start,
            $chr_end,
            $n,
            $type,
            $acc_ver,
            $ctg_start,
            $ctg_end,
            $ctg_ori,
            ) = @$file_line;    
            $seq = $pfetch->get_Seq_by_acc($acc_ver);
        }
        
        next unless ($type eq 'F');

        #split ino accesion number and version number 
        my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
        
        # translate orientation to integer
        if ($ctg_ori eq '-') {
            $ctg_ori = -1;
        }
        elsif ($ctg_ori eq '+') {
            $ctg_ori = 1;
        }
        else {
            die "Invalid orientation '$ctg_ori'";
        }

        
        
        # next line stores the details of that contig in the database and returns the dbID
        my $ctg_id = clone_to_db($pipe_clone_adaptor ,$seq,  $acc ,$sv);                       
        
        # assembly details get put into a 2D array corresponding to columns in the assembly table of the db
        push(@sgp_pipe, [
                $pipe_chromosome->dbID,
                $chr_start, $chr_end,
                $super_contig_name,
                $chr_start, $chr_end,
                $superctg_ori,
                $ctg_id,
                $ctg_start, $ctg_end,
                $ctg_ori,
                $set_name ]
            );                 

        # again for otter db
        $ctg_id = clone_to_db($otter_clone_adaptor ,$seq,  $acc ,$sv);
        push (@sgp_otter, [
                    $otter_chromosome->dbID,
                    $chr_start, $chr_end,
                    $super_contig_name,
                    $chr_start, $chr_end,
                    $superctg_ori ,
                    $ctg_id,
                    $ctg_start, $ctg_end,
                    $ctg_ori,
                    $set_name]);
        
        
        ## store_input_id_analysis($pipeline_db, $clone->embl_id) ;
        ## update input_id_analysis table
        eval{
            $state_info->store_input_id_analysis( $acc_ver . ".1."  . ($seq->length + 1)  , $ana_obj );
        };
        if ($@){
            print STDERR "could not enter values to input_id_analysis table\n$@"; 
        }
        
    }  #-----end of read in file loop


   # Get ready the statements for inserting into the assembly table
    my $insert_query = q{
        INSERT assembly ( 
            chromosome_id
            , chr_start, chr_end
            , superctg_name
            , superctg_start, superctg_end
            , superctg_ori
            , contig_id
            , contig_start, contig_end
            , contig_ori
            , type )
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)
            } ;
    my $pipe_assembly_insert  = $pipeline_db->prepare($insert_query);   
    my $otter_assembly_insert = $otter_db   ->prepare($insert_query); 
    
    
    foreach my $line_otter (@sgp_otter) {
        
        # add the appropriate chromosome_id before executing the query        
        eval{ 
            my $line_pipe = shift(@sgp_pipe); # 
            $otter_assembly_insert->execute(@$line_otter) or warn "Couldn\'t execute \"INSERT assembly ...\" statement in otterdb";
            $pipe_assembly_insert->execute(@$line_pipe) or warn "Couldn\'t execute statement in pipeline db " 
        } ;
        
        if ($@){
            print STDERR "Could not write to databases error was $@\n";
        }    
    }

    #update chromosome length now. - set to max value of chr end in assembly table
    # I am doing this as two seperate entries, incase one databases contains previous entries that the other doesnt.
    update_chromosome_length($pipeline_db, $pipe_chromosome);
    update_chromosome_length($otter_db, $otter_chromosome);

     
    # benchmarking 
#    my $t1 = new Benchmark;
#    my $td = timediff($t1, $t0);
#    print STDERR "code took: ", timestr($td) , "\n";

}
#------------------end of main script -------------------------------------------------------







#               Subroutines
#--------------------------------------------------------------------------------------------------------------------------
#

# 
sub store_clone{
    my ($clone_adaptor, $clone) = @_ ;
    
    my $acc_ver = $clone->id;

    my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
 
        eval{ $clone_adaptor->store($clone);  };
        if($@){
            print STDERR "Problems writing " . $clone->id . " to database. \nProblem was " . $@;             
        }

}


#------------------------------------------------------------------------------

# check if a set with that name exists 
# if it deosnt exist update databases with appropritae entry;
# it returns the last cromosome end coordinate in that sequence set 
sub check_sequence_set {
    my ($db, $name) = @_;
    my $value = 0;
    
    my $sth = $db->prepare("SELECT count(*) FROM sequence_set WHERE assembly_type = '$name' ");
    $sth->execute();
    my ($count) = $sth->fetchrow;
    if ($count){
        
        if ($input_type  eq  'AGP'){
            $sth->finish;
            print STDERR "this exists already in the " . $db->dbname . " database\n";
            die "sorry, can't have the same name as an existing set (when using an agp file)";
        }
        else{
            ## input must be a list of accessions - append to end of existing set
            print STDERR "we already have that sequence set name in ". $db->dbname . ". Entires will be appended to end\n";    
            $sth = $db->prepare("SELECT max(chr_end) FROM assembly WHERE type = '$name'");
            $sth->execute;
            if (my $row = $sth->fetchrow){
                $value = $row;
            }       
        }
    }
    else{
        
        ## so there is no entry in the sequence set table- create an entry then
        $sth = $db->prepare(q{INSERT INTO sequence_set (assembly_type , description , analysis_priority) VALUES (?,?,?)});
        my @values;
        @values->[0] = $name;
        @values->[1] = "description test" ; # need to get this from the command line
        @values->[2] = 5 ;
                
        $sth->execute(@values) or warn "could not enter information into the sequence set table of otter" ; 
        
    }
 
    return $value;
}

#---------------------------------------------------------------------------------------------------

# returns a chromosome when given a db object and a chromosome name
sub get_chromosome{
    
    my ($db , $chr_name) = @_;
 
    my $chr_adp = $db->get_ChromosomeAdaptor();
    my $chr;
    eval{  $chr = $chr_adp->fetch_by_chr_name($chr_name) };    
    
    if (! $@) {   # if no errors with getting the chromosome 
        return $chr;
    }
    else{
        ## put a new chromosome into the db to get its id # note that the length value is a default value and will be set later 
        my $chr = Bio::EnsEMBL::Chromosome->new(
                                                -chr_name      => $chr_name,
                                                -adaptor       => $chr_adp,
                                                -length       => 1 
                                                );
           $chr_adp->store($chr);
        return $chr;     
    }
}

#-----------------------------------------------------------------------------------------------------------------------
## updates the chromosome length field after assembly table has had values entered
sub update_chromosome_length{
    
     my ($db, $chromosome) = @_ ;
         
     my $chr_id = $chromosome->dbID;
     
     my $chr_length_query = qq{ SELECT max(chr_end) FROM assembly WHERE chromosome_id = $chr_id } ;   
     my $sth = $db->prepare($chr_length_query);
     if($sth->execute()){
         my $chr_end = $sth->fetchrow ;
         if (!defined $chr_end) {$chr_end = 0}; 
     
         $sth = $db->prepare("UPDATE chromosome SET length = $chr_end WHERE chromosome_id = $chr_id");
         if ($sth->execute){  
         }
         else{
            warn "Couldn't update the chromosome";
         } 
     
     }
     else{
         warn "Couldn't find the max_end value for chromosome with ID: $chr_id";
     }   
}


#------------------------------------------------------------------------------------------------------------------------------------

# check if clone is in db already not used yet, but will be when i tidy up the code.
# takes the db adaptor and accession and version number
sub clone_to_db{
    
    my ( $adaptor, $seq , $acc , $seq_ver) = @_ ; 
    my $clone;
    
    eval { $clone = $adaptor->fetch_by_accession_version($acc , $seq_ver); };
    if (! $@){
        warn "this clone is already in the " . $adaptor->db->dbname . " database" ;
        my $contigs = $clone->get_all_Contigs;
        if (scalar(@$contigs) != 1){
            die "more than 1 contig for clone " . $acc ; 
        }    
    }
    else{
                
        $clone = Bio::EnsEMBL::Clone->new();
        $clone->htg_phase(3);
        $clone->id("$acc.$seq_ver");
        $clone->embl_id($acc);
        $clone->version(1);
        $clone->embl_version($seq_ver);
        $clone->created(time);
        $clone->modified(time);
 
        #    create and add contig(s) to the clone
        ##   now we only expect one contig per clone
        my $contig = Bio::EnsEMBL::RawContig->new;
        my $end = $seq->length;

 
        $contig->name("$acc.$seq_ver.1." . $seq->length);
        $contig->length($seq->length);
        $contig->seq($seq->seq);
        $clone->add_Contig($contig);
 
        ##------------------
        store_clone($adaptor , $clone);       
    }
    
   
    my $contigs = $clone->get_all_Contigs;
    my $ctg_id = @$contigs->[0]->dbID;
              
    return $ctg_id;
}  
    
#------------------------------------------------------------------------------------------


sub get_pipeline_options {
    my( $db ) = @_;
    
    my $sth = $db->prepare("SELECT meta_value FROM meta WHERE meta_key = 'pipeline_db'");
    $sth->execute;
    my ($opt_str) = $sth->fetchrow;
    if ($opt_str) {
        my $options_hash = {eval $opt_str};
        if ($@) {
            die "Error evaluating '$opt_str' : $@";
        }
        return $options_hash
    } else {
        return;
    }
}

sub save_pipeline_options {
    my( $db, $options_hash ) = @_;
    
    my $host    = $options_hash->{-HOST};
    my $port    = $options_hash->{-PORT};
    my $user    = $options_hash->{-USER};
    my $pass    = $options_hash->{-PASS};
    my $dbname  = $options_hash->{-DBNAME};
   
   
       
    my $opt_str = qq{
        -HOST   => '$host',
        -PORT   => '$port',
        -USER   => '$user',
        -PASS   => '$pass',
        -DBNAME => '$dbname',
        };
    my $sth = $db->prepare("INSERT INTO meta(meta_key, meta_value) VALUES (?,?)");
    $sth->execute('pipeline_db', $opt_str);
}
