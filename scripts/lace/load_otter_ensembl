#!/usr/local/bin/perl -w

=head1 NAME

load_otter_ensembl

=head1 SYNOPSIS
 
  load_otter_ensembl <AGP>

=head1 DESCRIPTION

This script reads the assembly information from
an agp file and pfetches the clone and contig
details based on the accession.  It then
populates the assembly table in both databases.

BEWARE! It assumes 1 contig for each clone.

example;
./Load_otter_ensembl -host ecs1d -user ensadmin -pass "ensembl" -dbname otter_test -name mySequenceSet -description 'test description' -chromosome chr12 clone_list

=head1 OPTIONS

    
    -host           host name for the otter database (gets put as host= in locator)
    -port           port number of the otter database
    -user           username for the otter database
    -pass           password for the otter databases
    -dbname         what the name of otter database to connect is (dbname= in locator)
    
    -pipehost       host name for the pipeline database
    -pipeport       port for the pipeline databases
    -pipeuser       username for the pipeline database
    -pipepass       password fro the pipeline database
    -pipedbname     name of the pipeline database to connect to
    
    -name           name of the set of clones
    -description    description of thesequence set 
    -priority       analysis priority of the sequnce set
    -chromosome     name of the chromosome the set comes from
       
       
    -module         Module name to load (Defaults to Bio::EnsEMBL::DBSQL::DBAdaptor)
    
    -help           displays this documentation with PERLDOC

    user should also supply either a list of accession numbers (one per line) or a .agp (golden path) file.
    

    NOTE: The first time this script is run, it expects arguments for the pipeline database (port, password, etc may be optional , depending on the way the database has been set up).
    These are then stored in  the otter database, so after that the user need only specify the otter database options and the set name and description.

=cut


use Benchmark;

use strict;
use Getopt::Long;
use Bio::SeqIO;
use Bio::EnsEMBL::Analysis;
use Bio::EnsEMBL::Clone;
use Bio::EnsEMBL::RawContig;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch;
use Bio::EnsEMBL::Chromosome;

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Clone;
use Bio::Otter::Lace::SatelliteDB;

{
#    my $t0 = new Benchmark; # test the time taken for the script to run.
    
    # some important variables (and some less inportant ones that look neater up here) 
    my $input_type;     # AGP or LIST
    my $sth ;                 # used as a variable for storing the various statement handles used through the script
    my $agp_file ;            # the file containing the assembly details
    my $pipe_analysis ;       # analysis adaptor for the pipeline db
    my $pipe_clone_adaptor ;  # clone adaptor for the pipeline db
    my $otter_analysis ;      # analysis adaptor for the otter deb
    my $otter_clone_adaptor;  # clone adaptor for the otter db
    my $chromosome_id ;
    my @sgp ;           #static golden path. stores an array of arrays. each sub array contains the details for 1 row in the asembly table effectivley
    my @sgp_pipe ;
    my @sgp_otter;
    my @alternative_id ;      # stores the id of contigs for one of the dbs
    my $sv;                   # sequence version
    my $module = 'Bio::EnsEMBL::DBSQL::DBAdaptor';
    my @file_values;          # stores the values given in each line of input as an array of the component parts
    my $chromosome_name;
    my $set_name;
    my $end_coord;            # stores the end coord of the last contig in sequence set - used when appending contigs to a previous set  
              
    
    
    ## next set of variables are overwritten if a command line option is specified
    my $host = 'localhost'; # holds the (default) value for the otter port
    my $port = 3306;        # holds the (default) value for the otter port 
    my $dbname = 'otter';   # holds the (default) value for the otter database name
    my $analysis_priority =  5; # hold the deafulat value for the analysis priority 
    my $description;    
    
    my(                                      $dbuser,     $dbpass ); ## stores the otter username and password
    my( $pipehost, $pipeport, $pipedbname, $pipedbuser, $pipedbpass );##stores the pipeline db and password
    ####---------------

    my $help = 0;
    &GetOptions(
            'host=s'        => \$host,
	    'port=i'        => \$port,
	    'user=s'        => \$dbuser,
	    'pass=s'        => \$dbpass,
            'dbname=s'      => \$dbname,

            'pipehost=s'    => \$pipehost,      
	    'pipeport=i'    => \$pipeport,      
	    'pipeuser=s'    => \$pipedbuser,    
	    'pipepass=s'    => \$pipedbpass,
            'pipedbname=s'  => \$pipedbname, 

	    'module=s'      => \$module,
       	    'h|help'        => \$help,
            'description=s' => \$description,
            'priority=i'    => \$analysis_priority ,
            'chromosome=s'  => \$chromosome_name, 
            'set|name=s'        => \$set_name,
            ) || useage();
    useage() if $help;
    
    # Chr prefix causes problems for Apollo
    $chromosome_name =~ s/^chr//i if $chromosome_name;

    ## takes the remaining argument as the filename to be read
    $agp_file = $ARGV[0];
    if (! defined $agp_file ) {warn 'cannot load assembly details, as there is no agp file';}
    open AGP, "$agp_file" or die "Can't read '$agp_file' : $!";

    # Make a connection to the otter database
    my $otter_db = Bio::EnsEMBL::DBSQL::DBAdaptor->new (   
        -HOST   => $host,
        -PORT   => $port,
        -USER   => $dbuser,
        -PASS   => $dbpass,
        -DBNAME => $dbname,
        );
        
    
    my $pipe_options = Bio::Otter::Lace::SatelliteDB::get_options_for_key($otter_db, 'pipeline_db');
    if ($pipe_options) {
        # Check none of the pipe options are set on command line
        if ($pipehost or $pipeport or $pipedbname or $pipedbuser or $pipedbpass) {
            die "pipeline db options are specified on command line, but are already stored in the otter db";
        }
    } else {
        # Pipeline database defaults to same values as otter
        $pipehost   ||= $host  ;
        $pipeport   ||= $port  ;
        $pipedbname ||= $dbname;
        $pipedbuser ||= $dbuser;
        $pipedbpass ||= $dbpass;
        
        $pipe_options = {
            -HOST   => $pipehost,
            -PORT   => $pipeport,
            -USER   => $pipedbuser,
            -PASS   => $pipedbpass,
            -DBNAME => $pipedbname,
            };
            
        Bio::Otter::Lace::SatelliteDB::save_options_hash($otter_db, 'pipeline_db', $pipe_options);
    }
    
  
    my $pipeline_db = Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor->new(%$pipe_options);

    if ($help){
        exec('perldoc', $0); #runs perldoc on itself (variable $0 stores the program name)
    } 
    
    if (! defined $description){
        die "no description given" ;
    }

    if (! defined  $set_name){
        die "you need to give the set name as an argument";
    }





    #------------------------- read input file -----------------------------------------    
    # first go through file , check that the file contains the same chromosome for each entry store values an an array

    my $line_counter = 0;
    my $prev_chr_name ='';
    while(<AGP>){
        chomp;
        #print STDERR "reading line ". ($line_counter + 1) ."\n";
        $line_counter ++;    
    
        # 0       1       2       3       4       5               6       7       8     9
        # chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +     Optional comment
        # splits each line into its component parts - puts line in a temporary array (splits the line on whitespace)
        my @line_in_array = split /\s+/, $_, 10;
        #warn 'line: ', join(', ', map "'$_'", @line_in_array), "\n";
    
        if (scalar(@line_in_array) == 1) { 
            # cant think of anything to check  here yet
            # we will end up here if the input file has only a list of contigs in it. 
            $input_type = "LIST";
            if (! defined $chromosome_name) {
                # we need a chromosome name if only a list of contigs is given
                die "you need to provide the name of a chromosome when the input file is a list of clones";
            }
        }
        elsif ($line_in_array[4] eq 'F') {
            # we must have the full file rather than just clone names
            $input_type = "AGP";
            $chromosome_name = $line_in_array[0];
            
            # chr prefixes cause problems
            $chromosome_name =~ s/^chr//i;
            
            if ($prev_chr_name) {
                die "clones on different chromosomes: '$chromosome_name' and '$prev_chr_name'"
                    unless $chromosome_name eq $prev_chr_name;
            } else {
                $prev_chr_name = $chromosome_name;
            }
        }
        else {
            warn "Skipping: $_";
            next; 
        }
        ## store all values in this array, so that the file does not need to be re-read
        push (@file_values , [@line_in_array]);     
    }
    #--------------------------------finished reading input file ------------------------


    if ($chromosome_name =~ /chr/i) {
        die "Chromosome names containing 'chr' are illegal: '$chromosome_name'\n";
    }
    

    # die on INT signal    - should clean things up a bit , if program terminates early
    $SIG{INT} = sub {
        my $sig = shift;
        die "exited after SIG$sig";
        };


    # update the sequence sets table and return the coord of the last contig if available
    $end_coord          = check_and_save_sequence_set($otter_db,     $set_name, $description, $input_type);
    my $other_end_coord = check_and_save_sequence_set($pipeline_db , $set_name, $description, $input_type);
    if ($other_end_coord > $end_coord)  { $end_coord = $other_end_coord };
    
    
    # create an analysis adaptor and a clone adaptor for the otter database and then one of each for the pipeline db
    #$otter_analysis =      $otter_db->get_AnalysisAdaptor;
    $otter_clone_adaptor = $otter_db->get_CloneAdaptor;
    $pipe_analysis =      $pipeline_db->get_AnalysisAdaptor;
    $pipe_clone_adaptor = $pipeline_db->get_CloneAdaptor;
    
    ## default value for just now. - true value will be added by a different script
    my $superctg_ori = 1;  

    
    my $seq ; # stores the sequence (of each line entry) and name as a bio::seq object  
    
    # Get SubmitContig analysis object for priming the pipeline
    my $ana_obj = $pipe_analysis->fetch_by_logic_name('SubmitContig');
   
    unless ($ana_obj) {
         $ana_obj = new Bio::EnsEMBL::Pipeline::Analysis(
            -LOGIC_NAME     => 'SubmitContig',
            -INPUT_ID_TYPE  => 'CONTIG',
            );

         $pipe_analysis->store($ana_obj);
    }
    my $state_info = $pipeline_db->get_StateInfoContainer;
    



    ## while loop effectively reads each line of a  *.agp file (that has already been done and stored in @file values)
    ## it pfetches the sequence details based on the accsession number and version.
    my ($super_contig_name, $chr_start,$chr_end, $n, $type, $acc_ver, $ctg_start, $ctg_end,$ctg_ori,) ; 
    my $otter_chromosome  =  get_chromosome($otter_db    , $chromosome_name );
    my $pipe_chromosome   =  get_chromosome($pipeline_db , $chromosome_name );
   
    foreach my $file_line (@file_values) {       
        my @value_array ;            
        if ($input_type eq 'LIST'){
            ## all we have is the list of contigs/clones - need to give default values for agp
            
            $acc_ver = $file_line->[0];
            $seq = pfetch_acc_sv($acc_ver);
            $super_contig_name = $chromosome_name;  # should be available from the command line if we have a clone list as input (or we would have died earlier)       
            $n = 5;    # does this get used for anything? - don't think so
            $type = 'F' ;        
            $ctg_ori =  '+';
            $chr_start =  $end_coord + 10000 ;
            $chr_end = ($chr_start + $seq->length - 1);
            $ctg_start = 1 ;
            $ctg_end =   $seq->length ; # $ctg_end = $ctg_start + length - 1 ; as we are starting at 1 just use length   
            $end_coord = $chr_end; # so that it is in a suitable position for next time              
        
        }
        else {
        # input file must be in AGP format
        # 0       1       2       3       4       5               6       7       8
        # chr_20  2808333 2934911 29      F       AL121905.0      101     126679  +
            (
            $super_contig_name,
            $chr_start,
            $chr_end,
            $n,
            $type,
            $acc_ver,
            $ctg_start,
            $ctg_end,
            $ctg_ori,
            ) = @$file_line;    
            $seq = pfetch_acc_sv($acc_ver);
        }
        
        if ($seq) {
            print STDERR "Sequence: $acc_ver\n";
        } else {
            die "Can't fetch sequence '$acc_ver'";
        }
        
        #split ino accesion number and version number 
        my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
        
        # translate orientation to integer
        if ($ctg_ori eq '-') {
            $ctg_ori = -1;
        }
        elsif ($ctg_ori eq '+') {
            $ctg_ori = 1;
        }
        else {
            die "Invalid orientation '$ctg_ori'";
        }

        
        
        # next line stores the details of that contig in the database and returns the dbID
        my($ctg_id, $ctg_name) = clone_to_db($pipe_clone_adaptor, $seq, $acc, $sv);                       
        
        # assembly details get put into a 2D array corresponding to columns in the assembly table of the db
        push(@sgp_pipe, [
                $pipe_chromosome->dbID,
                $chr_start, $chr_end,
                $super_contig_name,
                $chr_start, $chr_end,
                $superctg_ori,
                $ctg_id,
                $ctg_start, $ctg_end,
                $ctg_ori,
                $set_name ]
            );                 

        # again for otter db
        my ($otter_ctg_id) = clone_to_db($otter_clone_adaptor, $seq, $acc, $sv);
        push (@sgp_otter, [
                    $otter_chromosome->dbID,
                    $chr_start, $chr_end,
                    $super_contig_name,
                    $chr_start, $chr_end,
                    $superctg_ori ,
                    $otter_ctg_id,
                    $ctg_start, $ctg_end,
                    $ctg_ori,
                    $set_name]);
        
        
        ## update input_id_analysis table
        eval{
            $state_info->store_input_id_analysis($ctg_name, $ana_obj);
        };
        # Don't warn about duplicate entries - means that it is already in the db.
        if ($@ and $@ !~ /Duplicate entry/){
            print STDERR "could not enter values to input_id_analysis table\n$@"; 
        }
        
    }  #-----end of read in file loop


   # Get ready the statements for inserting into the assembly table
    my $insert_query = q{
        INSERT assembly ( 
            chromosome_id
            , chr_start, chr_end
            , superctg_name
            , superctg_start, superctg_end
            , superctg_ori
            , contig_id
            , contig_start, contig_end
            , contig_ori
            , type )
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)
            } ;
    my $pipe_assembly_insert  = $pipeline_db->prepare($insert_query);   
    my $otter_assembly_insert = $otter_db   ->prepare($insert_query); 
    
    
    foreach my $line_otter (@sgp_otter) {
             
        eval{ 
            my $line_pipe = shift(@sgp_pipe); # 
            $otter_assembly_insert->execute(@$line_otter);
            $pipe_assembly_insert->execute(@$line_pipe);
        } ;
        
        if ($@){
            print STDERR "Could not write to databases error was $@\n";
        }    
    }

    #update chromosome length now. - set to max value of chr end in assembly table
    # I am doing this as two seperate entries, incase one databases contains previous entries that the other doesnt.
    update_chromosome_length($pipeline_db, $pipe_chromosome);
    update_chromosome_length($otter_db, $otter_chromosome);

     
    # benchmarking 
#    my $t1 = new Benchmark;
#    my $td = timediff($t1, $t0);
#    print STDERR "code took: ", timestr($td) , "\n";

}
#------------------end of main script -------------------------------------------------------







#               Subroutines
#--------------------------------------------------------------------------------------------------------------------------
#

# 
sub store_clone{
    my ($clone_adaptor, $clone) = @_ ;
    
    my $acc_ver = $clone->id;

    my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
 
        eval{ $clone_adaptor->store($clone);  };
        if($@){
            print STDERR "Problems writing " . $clone->id . " to database. \nProblem was " . $@;             
        }

}

{
    my( $pfetch, $pfetch_archive );

    sub pfetch_acc_sv {
        my( $acc_ver ) = @_;
        
        $pfetch         ||= Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new;
        $pfetch_archive ||= Bio::EnsEMBL::Pipeline::SeqFetcher::Finished_Pfetch->new(
            -PORT => 23100,
            );
        return $pfetch->get_Seq_by_acc($acc_ver) || $pfetch_archive->get_Seq_by_acc($acc_ver);
    }
}

#------------------------------------------------------------------------------

# check if a set with that name exists 
# if it deosnt exist update databases with appropritae entry;
# it returns the last cromosome end coordinate in that sequence set 
sub check_and_save_sequence_set {
    my ($db, $name, $description, $input_type) = @_;
    my $max_chr_end = 0;
    
    my $sth = $db->prepare("SELECT count(*) FROM sequence_set WHERE assembly_type = '$name' ");
    $sth->execute();
    my ($count) = $sth->fetchrow;
    if ($count){
        
        if ($input_type  eq  'AGP'){
            $sth->finish;
            print STDERR "this exists already in the " . $db->dbname . " database\n";
            die "sorry, can't have the same name as an existing set (when using an agp file)";
        }
        else{
            ## input must be a list of accessions - append to end of existing set
            print STDERR "we already have that sequence set name in ". $db->dbname . ". Entires will be appended to end\n";    
            $sth = $db->prepare("SELECT max(chr_end) FROM assembly WHERE type = '$name'");
            $sth->execute;
            ($max_chr_end) = $sth->fetchrow;
        }
    }
    else{
        
        ## so there is no entry in the sequence set table- create an entry then
        $sth = $db->prepare(q{
            INSERT INTO sequence_set (assembly_type
                  , description
                  , analysis_priority)
            VALUES (?,?,?)
            });
        $sth->execute($name, $description, 5);
        
    }
    if (! defined  $max_chr_end){
        $max_chr_end = 0;
    } 
 
    return $max_chr_end;
}

#---------------------------------------------------------------------------------------------------

# returns a chromosome when given a db object and a chromosome name
sub get_chromosome{
    
    my ($db , $chr_name) = @_;
 
    my $chr_adp = $db->get_ChromosomeAdaptor();
    my $chr;
    eval{  $chr = $chr_adp->fetch_by_chr_name($chr_name) };    
    
    if (! $@) {   # if no errors with getting the chromosome 
        return $chr;
    }
    else{
        ## put a new chromosome into the db to get its id # note that the length value is a default value and will be set later 
        my $chr = Bio::EnsEMBL::Chromosome->new(
                                                -chr_name      => $chr_name,
                                                -adaptor       => $chr_adp,
                                                -length       => 1 
                                                );
           $chr_adp->store($chr);
        return $chr;     
    }
}

#-----------------------------------------------------------------------------------------------------------------------
## updates the chromosome length field after assembly table has had values entered
sub update_chromosome_length{
    
     my ($db, $chromosome) = @_ ;
         
     my $chr_id = $chromosome->dbID;
     
     my $chr_length_query = qq{ SELECT max(chr_end) FROM assembly WHERE chromosome_id = $chr_id } ;   
     my $sth = $db->prepare($chr_length_query);
     if($sth->execute()){
         my $chr_end = $sth->fetchrow ;
         if (!defined $chr_end) {$chr_end = 0}; 
     
         $sth = $db->prepare("UPDATE chromosome SET length = $chr_end WHERE chromosome_id = $chr_id");
         if ($sth->execute){  
         }
         else{
            warn "Couldn't update the chromosome";
         } 
     
     }
     else{
         warn "Couldn't find the max_end value for chromosome with ID: $chr_id";
     }   
}


#------------------------------------------------------------------------------------------------------------------------------------

# check if clone is in db already not used yet, but will be when i tidy up the code.
# takes the db adaptor and accession and version number
sub clone_to_db {
    my ( $adaptor, $seq , $acc , $seq_ver) = @_ ; 
    my $clone;
    
    eval { $clone = $adaptor->fetch_by_accession_version($acc , $seq_ver); };
    if (! $@){
        warn "this clone is already in the " . $adaptor->db->dbname . " database" ;
        my $contigs = $clone->get_all_Contigs;
        if (scalar(@$contigs) != 1){
            die "more than 1 contig for clone " . $acc ; 
        }    
    }
    else{
                
        $clone = Bio::EnsEMBL::Clone->new();
        $clone->htg_phase(3);
        $clone->id("$acc.$seq_ver");    ### Should set to international clone name
        $clone->embl_id($acc);
        $clone->version(1);
        $clone->embl_version($seq_ver);
        $clone->created(time);
        $clone->modified(time);
 
        #    create and add contig(s) to the clone
        ##   now we only expect one contig per clone
        my $contig = Bio::EnsEMBL::RawContig->new;
        my $end = $seq->length;

 
        $contig->name("$acc.$seq_ver.1." . $seq->length);
        $contig->length($seq->length);
        $contig->seq($seq->seq);
        $clone->add_Contig($contig);
 
        ##------------------
        store_clone($adaptor , $clone);       
    }
    
   
    my $contig = $clone->get_all_Contigs->[0];
              
    return($contig->dbID, $contig->display_id);
}  


sub useage{ exit(exec('perldoc', $0)); }

